FUNCTION  <SNR>139_AddScopedTags()
Called 6 times
Total time:   0.004103
 Self time:   0.002356

count  total (s)   self (s)
    6              0.000016     if !empty(a:parent)
    3              0.000005         let curpath = a:parent.fullpath
    3              0.000009         let pscope  = a:typeinfo.kind2scope[a:parent.fields.kind]
    3              0.000002     else
    3              0.000005         let curpath = ''
    3              0.000003         let pscope  = ''
    3              0.000002     endif
                            
    6              0.000012     let is_cur_tag = 'v:val.depth == a:depth'
                            
    6              0.000012     if !empty(curpath)
                                    " Check whether the tag is either a direct child at the current depth
                                    " or at least a proper grandchild with pseudo-tags in between. If it
                                    " is a direct child also check for matching scope.
    3              0.000022         let is_cur_tag .= ' && (v:val.path ==# curpath || match(v:val.path, ''\V\^\C'' . curpath . a:typeinfo.sro) == 0) && (v:val.path ==# curpath ? (v:val.scope ==# pscope) : 1) && v:val.fields.line >= a:parent.fields.line && v:val.fields.line <= a:maxline'
    3              0.000002     endif
                            
    6              0.000295     let curtags = filter(copy(a:tags), is_cur_tag)
                            
    6              0.000011     if !empty(curtags)
    6              0.000279         call filter(a:tags, '!(' . is_cur_tag . ')')
                            
    6              0.000012         let realtags   = []
    6              0.000011         let pseudotags = []
                            
   51              0.000075         while !empty(curtags)
   45              0.000088             let tag = remove(curtags, 0)
                            
   45              0.000072             if tag.path != curpath
                                            " tag is child of a pseudo-tag, so create a new pseudo-tag and
                                            " add all its children to it
                                            let pseudotag = s:ProcessPseudoTag(curtags, tag, a:parent, a:typeinfo, a:fileinfo)
                            
                                            call add(pseudotags, pseudotag)
                                        else
   45              0.000086                 call add(realtags, tag)
   45              0.000027             endif
   45              0.000023         endwhile
                            
                                    " Recursively add the children of the tags on the current level
   51              0.000050         for tag in realtags
   45              0.000073             let tag.parent = a:parent
                            
   45              0.000106             if !has_key(a:typeinfo.kind2scope, tag.fields.kind)
   42              0.000042                 continue
                                        endif
                            
    3              0.000006             if !has_key(tag, 'children')
    3              0.000006                 let tag.children = []
    3              0.000002             endif
                            
                                        " Check for tags with the exact same name that may be created
                                        " alternatively in a conditional (Issue #139). The only way to
                                        " distinguish between them is by line number.
    3              0.000040             let twins = filter(copy(realtags), "v:val.fullpath ==# '" . substitute(tag.fullpath, "'", "''", 'g') . "'" . " && v:val.fields.line != " . tag.fields.line)
    3              0.000006             let maxline = line('$')
    3              0.000004             for twin in twins
                                            if twin.fields.line <= maxline && twin.fields.line > tag.fields.line
                                                let maxline = twin.fields.line - 1
                                            endif
                                        endfor
                            
    3              0.000023             call s:AddScopedTags(a:tags, tag.children, tag, a:depth + 1, a:typeinfo, a:fileinfo, maxline)
    3              0.000008         endfor
    6              0.000019         call extend(a:processedtags, realtags)
                            
                                    " Recursively add the children of the tags that are children of the
                                    " pseudo-tags on the current level
    6              0.000012         for tag in pseudotags
                                        call s:ProcessPseudoChildren(a:tags, tag, a:depth, a:typeinfo, a:fileinfo)
                                    endfor
    6              0.000013         call extend(a:processedtags, pseudotags)
    6              0.000004     endif
                            
                                " Now we have to check if there are any pseudo-tags at the current level
                                " so we have to check for real tags at a lower level, i.e. grandchildren
    6              0.000012     let is_grandchild = 'v:val.depth > a:depth'
                            
    6              0.000008     if !empty(curpath)
    3              0.000012         let is_grandchild .= ' && match(v:val.path, ''\V\^\C'' . curpath . a:typeinfo.sro) == 0'
    3              0.000001     endif
                            
    6              0.000024     let grandchildren = filter(copy(a:tags), is_grandchild)
                            
    6              0.000011     if !empty(grandchildren)
                                    call s:AddScopedTags(a:tags, a:processedtags, a:parent, a:depth + 1, a:typeinfo, a:fileinfo, a:maxline)
                                endif

FUNCTION  neocomplete#helper#is_enabled_source()
Called 302 times
Total time:   0.033361
 Self time:   0.006075

count  total (s)   self (s)
  302   0.002148   0.001881   let source = type(a:source) == type('') ? get(neocomplete#variables#get_sources(), a:source, {}) : a:source
                            
  302   0.030760   0.003741   return !empty(source) && (empty(source.filetypes) ||     !empty(neocomplete#helper#ftdictionary2list(      source.filetypes, a:filetype)))  && (!get(source.disabled_filetypes, '_', 0) &&      empty(neocomplete#helper#ftdictionary2list(      source.disabled_filetypes, a:filetype)))

FUNCTION  <SNR>139_IsValidFile()
Called 8 times
Total time:   0.000669
 Self time:   0.000622

count  total (s)   self (s)
    8   0.000090   0.000043     call s:debug('Checking if file is valid [' . a:fname . ']')
                            
    8              0.000016     if a:fname == '' || a:ftype == ''
                                    call s:debug('Empty filename or type')
                                    return 0
                                endif
                            
    8              0.000105     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call s:debug('File not readable')
                                    return 0
                                endif
                            
    8              0.000212     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call s:debug('File is marked as ignored')
                                    return 0
                                endif
                            
    8              0.000009     if &previewwindow
                                    call s:debug('In preview window')
                                    return 0
                                endif
                            
    8              0.000029     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call s:debug('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
    8              0.000003     return 1

FUNCTION  neocomplete#variables#get_sources()
Called 59 times
Total time:   0.000495
 Self time:   0.000495

count  total (s)   self (s)
   59              0.000239   if !exists('s:sources')
                                let s:sources = {}
                              endif
   59              0.000065   return s:sources

FUNCTION  syntastic#log#debug()
Called 69 times
Total time:   0.000807
 Self time:   0.000476

count  total (s)   self (s)
   69   0.000696   0.000365     if !s:_isDebugEnabled(a:level)
   69              0.000050         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 2 times
Total time:   0.002156
 Self time:   0.000162

count  total (s)   self (s)
    8              0.000015     for Fn in a:list
    8   0.002092   0.000098       let code = call(Fn, a:000)
    8              0.000012       if code != 0
    2              0.000004         return code
                                  endif
    6              0.000013     endfor
                                return 0

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 144 times
Total time:   0.000497
 Self time:   0.000497

count  total (s)   self (s)
  144              0.000215   if a:text ==# 'added'
  129              0.000121     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
    6              0.000007     return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
    9              0.000009     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 3 times
Total time:   0.000069
 Self time:   0.000029

count  total (s)   self (s)
    3   0.000067   0.000027   return 'cd ' . gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()) . ' && ' . a:cmd

FUNCTION  gitgutter#process_buffer()
Called 5 times
Total time:   0.070410
 Self time:   0.000468

count  total (s)   self (s)
    5   0.000144   0.000040   call gitgutter#utility#set_buffer(a:bufnr)
    5   0.000412   0.000029   if gitgutter#utility#is_active()
    5              0.000010     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
    5              0.000004     try
    5   0.000029   0.000018       if !a:realtime || gitgutter#utility#has_fresh_changes()
    3   0.041506   0.000078         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 1)
    3   0.002009   0.000043         call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(diff))
    3   0.003737   0.000031         let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
    3              0.000013         if len(modified_lines) > g:gitgutter_max_signs
                                      call gitgutter#utility#warn('exceeded maximum number of signs (configured by g:gitgutter_max_signs).')
                                      call gitgutter#sign#clear_signs()
                                      return
                                    endif
                            
    3              0.000004         if g:gitgutter_signs || g:gitgutter_highlight_lines
    3   0.022353   0.000040           call gitgutter#sign#update_signs(modified_lines)
    3              0.000001         endif
                            
    3   0.000048   0.000017         call gitgutter#utility#save_last_seen_change()
    3              0.000003       endif
    5              0.000006     catch /diff failed/
                                  call gitgutter#hunk#reset()
                                endtry
    5              0.000004   else
                                call gitgutter#hunk#reset()
                              endif

FUNCTION  airline#extensions#unite#apply()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000004   if &ft == 'unite'
                                call a:1.add_section('airline_a', ' Unite ')
                                call a:1.add_section('airline_b', ' %{get(unite#get_context(), "buffer_name", "")} ')
                                call a:1.add_section('airline_c', ' %{unite#get_status_string()} ')
                                call a:1.split()
                                call a:1.add_section('airline_y', ' %{get(unite#get_context(), "real_buffer_name", "")} ')
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 271 times
Total time:   0.001680
 Self time:   0.001680

count  total (s)   self (s)
  271              0.000669   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  271              0.000164   return ''

FUNCTION  neocomplete#is_cache_disabled()
Called 558 times
Total time:   0.023785
 Self time:   0.015518

count  total (s)   self (s)
  558              0.002147   let ignore_filetypes = ['fuf', 'ku']
  558              0.002459   let bufnr = a:0 > 0 ? a:1 : bufnr('%')
  558   0.018493   0.010226   return !neocomplete#is_enabled() || index(ignore_filetypes, &filetype) >= 0 || neocomplete#get_current_neocomplete().lock || (g:neocomplete#lock_buffer_name_pattern != '' &&   bufname(bufnr) =~ g:neocomplete#lock_buffer_name_pattern)

FUNCTION  <SNR>128_check_mixed_indent()
Called 5 times
Total time:   0.002030
 Self time:   0.002030

count  total (s)   self (s)
    5              0.000010   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less then tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              else
    5              0.001948     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  neocomplete#get_context_filetype()
Called 1089 times
Total time:   0.015446
 Self time:   0.013965

count  total (s)   self (s)
 1089              0.004578   let neocomplete = exists('b:neocomplete') ? b:neocomplete : neocomplete#get_current_neocomplete()
                            
 1089              0.003635   if a:0 != 0 || mode() !=# 'i' || neocomplete.context_filetype == ''
   52   0.001776   0.000295     call neocomplete#context_filetype#set()
   52              0.000040   endif
                            
 1089              0.001194   return neocomplete.context_filetype

FUNCTION  neocomplete#util#uniq()
Called 20 times
Total time:   0.035860
 Self time:   0.000239

count  total (s)   self (s)
   20   0.035835   0.000214   return call(s:get_list().uniq, a:000)

FUNCTION  neocomplete#helper#get_force_omni_complete_pos()
Called 279 times
Total time:   0.014208
 Self time:   0.008283

count  total (s)   self (s)
                              " Check eskk complete length.
  279   0.002150   0.001054   if neocomplete#is_eskk_enabled() && exists('g:eskk#start_completion_length')
                                if !neocomplete#is_eskk_convertion(a:cur_text) || !neocomplete#is_multibyte_input(a:cur_text)
                                  return -1
                                endif
                            
                                let complete_pos = call(&l:omnifunc, [1, ''])
                                let complete_str = a:cur_text[complete_pos :]
                                return (neocomplete#util#mb_strlen(complete_str) >= g:eskk#start_completion_length) ? complete_pos : -1
                              endif
                            
  279   0.004934   0.001148   let filetype = neocomplete#get_context_filetype()
  279              0.000521   let omnifunc = &l:omnifunc
                            
  279   0.002196   0.001153   if neocomplete#helper#check_invalid_omnifunc(omnifunc)
  279              0.000265     return -1
                              endif
                            
                              if has_key(g:neocomplete#force_omni_input_patterns, omnifunc)
                                let pattern = g:neocomplete#force_omni_input_patterns[omnifunc]
                              elseif filetype != '' && get(g:neocomplete#force_omni_input_patterns, filetype, '') != ''
                                let pattern = g:neocomplete#force_omni_input_patterns[filetype]
                              else
                                return -1
                              endif
                            
                              return match(a:cur_text, '\%(' . pattern . '\m\)$')

FUNCTION  <SNR>139_GetNearbyTag()
Called 60 times
Total time:   0.011832
 Self time:   0.011217

count  total (s)   self (s)
   60              0.000087     if s:nearby_disabled
                                    return {}
                                endif
                            
   60   0.000621   0.000347     let fileinfo = s:known_files.getCurrent(a:forcecurrent)
   60              0.000106     if empty(fileinfo)
                                    return {}
                                endif
                            
   60              0.000109     let typeinfo = fileinfo.typeinfo
   60              0.000062     if a:0 > 0
                                    let curline = a:1
                                else
   60              0.000145         let curline = line('.')
   60              0.000044     endif
   60              0.000104     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
  935              0.001217     for line in range(curline, 1, -1)
  935              0.002006         if has_key(fileinfo.fline, line)
   60              0.000167             let curtag = fileinfo.fline[line]
   60   0.000719   0.000378             if a:all || typeinfo.getKind(curtag.fields.kind).stl
   60              0.000103                 let tag = curtag
   60              0.000059                 break
                                        endif
                                    endif
  875              0.000563     endfor
                            
   60              0.000052     return tag

FUNCTION  neocomplete#helper#ftdictionary2list()
Called 302 times
Total time:   0.027019
 Self time:   0.003168

count  total (s)   self (s)
  302   0.026809   0.002958   return map(filter(neocomplete#get_source_filetypes(a:filetype), 'has_key(a:dictionary, v:val)'), 'a:dictionary[v:val]')

FUNCTION  neocomplete#context_filetype#set()
Called 52 times
Total time:   0.001481
 Self time:   0.001083

count  total (s)   self (s)
   52   0.000686   0.000288   let neocomplete = neocomplete#get_current_neocomplete()
   52              0.000226   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
   52              0.000090   if context_filetype == ''
                                let context_filetype = 'nothing'
                              endif
   52              0.000125   let neocomplete.context_filetype = context_filetype
                            
   52              0.000076   return neocomplete.context_filetype

FUNCTION  syntastic#log#debugShowOptions()
Called 3 times
Total time:   0.000028
 Self time:   0.000021

count  total (s)   self (s)
    3   0.000019   0.000012     if !s:_isDebugEnabled(a:level)
    3              0.000003         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val)))")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#check_mode()
Called 298 times
Total time:   0.386564
 Self time:   0.021371

count  total (s)   self (s)
  298              0.001249   let context = s:contexts[a:winnr]
                            
  298              0.000941   if get(w:, 'airline_active', 1)
  271              0.000670     let l:m = mode()
  271              0.000511     if l:m ==# "i"
  157              0.000306       let l:mode = ['insert']
  157              0.000160     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                else
  114              0.000276       let l:mode = ['normal']
  114              0.000085     endif
  271              0.001316     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  271              0.000237   else
   27              0.000053     let l:mode = ['inactive']
   27              0.000119     let w:airline_current_mode = get(g:airline_mode_map, '__')
   27              0.000019   endif
                            
  298              0.000907   if g:airline_detect_modified && &modified
  241              0.000826     call add(l:mode, 'modified')
  241              0.000188   endif
                            
  298              0.000441   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  298              0.000412   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
  298              0.001115   let mode_string = join(l:mode)
  298              0.001325   if get(w:, 'airline_lastmode', '') != mode_string
   27   0.002477   0.000185     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   27   0.363203   0.000302     call airline#highlighter#highlight(l:mode)
   27              0.000083     let w:airline_lastmode = mode_string
   27              0.000014   endif
                            
  298              0.000262   return ''

FUNCTION  gitgutter#diff#is_modified_and_added()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000007   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  unite#util#is_sudo()
Called 9 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    9              0.000050   return $SUDO_USER != '' && $USER !=# $SUDO_USER && $HOME !=# expand('~'.$USER) && $HOME ==# expand('~'.$SUDO_USER)

FUNCTION  airline#util#append()
Called 813 times
Total time:   0.008819
 Self time:   0.008819

count  total (s)   self (s)
  813              0.001698   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  813              0.002993   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  813              0.002311   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  neocomplete#get_current_neocomplete()
Called 2799 times
Total time:   0.020307
 Self time:   0.020307

count  total (s)   self (s)
 2799              0.007584   if !exists('b:neocomplete')
                                call neocomplete#init#_current_neocomplete()
                              endif
                            
 2799              0.003142   return b:neocomplete

FUNCTION  neocomplete#complete#_set_results_pos()
Called 262 times
Total time:   0.131030
 Self time:   0.034882

count  total (s)   self (s)
                              " Initialize sources.
  262   0.002921   0.001088   let neocomplete = neocomplete#get_current_neocomplete()
                            
  262   0.004440   0.001041   let filetype = neocomplete#get_context_filetype()
  262              0.001374   let sources = (a:0 > 0) ? a:1 : (filetype ==# neocomplete.sources_filetype) ? neocomplete.sources : neocomplete#helper#get_sources_list()
                            
  262              0.000996   let pos = winsaveview()
                            
                              " Try source completion. "{{{
  262              0.000440   let complete_sources = []
  524   0.031257   0.002962   for source in filter(values(sources), 'neocomplete#helper#is_enabled_source(v:val, filetype)')
  262              0.000393     if !source.loaded
                                  call neocomplete#helper#call_hook(source, 'on_init', {})
                                  let source.loaded = 1
                                endif
                            
  262              0.000487     let context = source.neocomplete__context
  262              0.000673     let context.input = a:cur_text
                            
  262              0.000249     try
  262   0.065613   0.002992       let complete_pos = has_key(source, 'get_complete_position') ? source.get_complete_position(context) : neocomplete#helper#match_word(context.input,    neocomplete#get_keyword_pattern_end(filetype, source.name))[0]
  262              0.000204     catch
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  call neocomplete#print_error( 'Error occurred in source''s get_complete_position()!')
                                  call neocomplete#print_error( 'Source name is ' . source.name)
                                  return complete_sources
                                finally
  262              0.001302       if winsaveview() != pos
                                    call winrestview(pos)
                                  endif
  262              0.000211     endtry
                            
  262              0.000317     if complete_pos < 0
  262              0.000487       let context.complete_pos = -1
  262              0.000401       let context.complete_str = ''
  262              0.000282       continue
                                endif
                            
                                let complete_str = context.input[complete_pos :]
                                if neocomplete#is_auto_complete() && len(complete_str) < source.min_pattern_length
                                  " Skip.
                                  let context.complete_pos = -1
                                  let context.complete_str = ''
                                  continue
                                endif
                            
                                let context.complete_pos = complete_pos
                                let context.complete_str = complete_str
                                call add(complete_sources, source)
                              endfor
                              "}}}
                            
  262              0.000321   return complete_sources

FUNCTION  SyntaxCheckers_cs_mcs_GetLocList()
Called 3 times
Total time:   0.484181
 Self time:   0.000151

count  total (s)   self (s)
    3   0.001374   0.000025     let makeprg = self.makeprgBuild({ 'args_after': '--parse' })
                            
    3              0.000006     let errorformat = '%f(%l\,%c): %trror %m'
                            
    3   0.482783   0.000102     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'defaults': {'bufnr': bufnr('')} })

FUNCTION  neocomplete#get_cur_text()
Called 279 times
Total time:   0.026525
 Self time:   0.003220

count  total (s)   self (s)
                              " Return cached text.
  279   0.002843   0.001067   let neocomplete = neocomplete#get_current_neocomplete()
  279   0.023321   0.001792   return (a:0 == 0 && mode() ==# 'i' &&  neocomplete.cur_text != '') ? neocomplete.cur_text : neocomplete#helper#get_cur_text()

FUNCTION  neocomplete#handler#_on_write_post()
Called 3 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
                              " Restore foldinfo.
    3              0.000041   for winnr in filter(range(1, winnr('$')), "!empty(getwinvar(v:val, 'neocomplete_foldinfo'))")
                                let neocomplete_foldinfo = getwinvar(winnr, 'neocomplete_foldinfo')
                                call setwinvar(winnr, '&foldmethod', neocomplete_foldinfo.foldmethod)
                                call setwinvar(winnr, '&foldexpr', neocomplete_foldinfo.foldexpr)
                                call setwinvar(winnr, 'neocomplete_foldinfo', {})
                              endfor

FUNCTION  airline#themes#get_highlight()
Called 1242 times
Total time:   0.140934
 Self time:   0.008656

count  total (s)   self (s)
 1242   0.140477   0.008199   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>130_get_syn()
Called 2512 times
Total time:   0.076062
 Self time:   0.076062

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
 2512              0.017426   let mode = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? 'gui' : 'cterm'
 2512              0.017163   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
 2512              0.005586   if empty(color) || color == -1
  512              0.003735     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
  512              0.000359   endif
 2512              0.004818   if empty(color) || color == -1
                                if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
 2512              0.002170   return color

FUNCTION  syntastic#util#shescape()
Called 6 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    6              0.000081     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>125_get_hunks()
Called 270 times
Total time:   0.011039
 Self time:   0.005038

count  total (s)   self (s)
  270              0.000708   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let s:source_func = 's:get_hunks_changes'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
  270   0.007468   0.001467   return {s:source_func}()

FUNCTION  <SNR>190_make_cache_current_buffer()
Called 20 times
Total time:   0.001441
 Self time:   0.000485

count  total (s)   self (s)
   20   0.000898   0.000098   let filetype = neocomplete#get_context_filetype(1)
                            
   20              0.000092   if !has_key(s:member_sources, bufnr('%'))
                                call s:initialize_source(bufnr('%'), filetype)
                              endif
                            
   20   0.000338   0.000182   call s:make_cache_lines(bufnr('%'), filetype, getline(a:start, a:end))

FUNCTION  <SNR>85_CacheErrors()
Called 3 times
Total time:   0.489506
 Self time:   0.001024

count  total (s)   self (s)
    3   0.000050   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    3   0.001259   0.000015     call s:ClearCache()
    3   0.000175   0.000019     let newLoclist = g:SyntasticLoclist.New([])
                            
    3   0.000357   0.000013     if !s:_skip_file()
                                    " debug logging {{{3
    3   0.000052   0.000018         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    3   0.000371   0.000180         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    3   0.000134   0.000072         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    3   0.000099   0.000039         let filetypes = s:_resolve_filetypes([])
    3   0.000067   0.000027         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    3              0.000010         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    3              0.000010         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    3              0.000004         let clist = []
    6              0.000010         for type in filetypes
    3   0.000365   0.000034             call extend(clist, s:registry.getCheckers(type, a:checker_names))
    3              0.000003         endfor
                            
    3              0.000004         let names = []
    3              0.000006         let unavailable_checkers = 0
    6              0.000010         for checker in clist
    3   0.000055   0.000037             let cname = checker.getFiletype() . '/' . checker.getName()
    3   0.000151   0.000013             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    3   0.000039   0.000016             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    3   0.485517   0.000044             let loclist = checker.getLocList()
                            
    3   0.000034   0.000020             if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    3              0.000003         endfor
                            
                                    " set names {{{3
    3              0.000004         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    3              0.000006         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    3   0.000037   0.000017         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    3              0.000004         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    3              0.000002     endif
                            
    3   0.000319   0.000011     call newLoclist.deploy()

FUNCTION  <SNR>137_add_register()
Called 66 times
Total time:   0.001436
 Self time:   0.001436

count  total (s)   self (s)
   66              0.000433   let reg = [getreg(a:name), getregtype(a:name)]
   66              0.000343   if get(s:prev_registers, a:name, []) ==# reg
                                " Skip same register value.
   57              0.000047     return
                              endif
                            
    9              0.000037   let len_history = len(reg[0])
                              " Ignore too long yank.
    9              0.000296   if len_history < 2 || len_history > 100000 || reg[0] =~ '[\x00-\x09\x10-\x1a\x1c-\x1f]\{3,}'
                                return
                              endif
                            
    9              0.000031   let s:prev_registers[a:name] = reg
                            
                              " Append register value.
    9              0.000050   call insert(s:yank_histories, reg)

FUNCTION  <SNR>86__translateElement()
Called 3 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
    3              0.000009     let fkey = a:key
    3              0.000015     if fkey[0] ==# '!'
                                    let fkey = fkey[1:]
                                    let not = 1
                                else
    3              0.000007         let not = 0
    3              0.000001     endif
                            
    3              0.000006     if fkey ==? 'level'
    3              0.000004         let op = not ? ' ==? ' : ' !=? '
    3              0.000024         let ret = 'v:val["type"]' . op . string(a:term[0])
    3              0.000004     elseif fkey ==? 'type'
                                    if a:term ==? 'style'
                                        let op = not ? ' ==? ' : ' !=? '
                                        let ret = 'get(v:val, "subtype", "")' . op . '"style"'
                                    else
                                        let op = not ? '!' : ''
                                        let ret = op . 'has_key(v:val, "subtype")'
                                    endif
                                elseif fkey ==? 'regex'
                                    let op = not ? ' =~? ' : ' !~? '
                                    let ret = 'v:val["text"]' . op . string(a:term)
                                elseif fkey ==? 'file' || fkey[:4] ==? 'file:'
                                    let op = not ? ' =~# ' : ' !~# '
                                    let ret = 'bufname(str2nr(v:val["bufnr"]))'
                                    let mod = fkey[4:]
                                    if mod !=# ''
                                        let ret = 'fnamemodify(' . ret . ', ' . string(mod) . ')'
                                    endif
                                    let ret .= op . string(a:term)
                                else
                                    call syntastic#log#warn('quiet_messages: ignoring invalid key ' . strtrans(string(fkey)))
                                    let ret = '1'
                                endif
    3              0.000003     return ret

FUNCTION  gitgutter#diff#is_added()
Called 21 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   21              0.000081   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>135_add_section()
Called 10 times
Total time:   0.000927
 Self time:   0.000407

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   10              0.000027     if a:key == 'warning'
    1   0.000052   0.000040       call a:builder.add_raw('%(')
    1              0.000002     endif
   10   0.000665   0.000163     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   10              0.000027     if a:key == 'warning'
    1   0.000011   0.000005       call a:builder.add_raw('%)')
    1              0.000002     endif

FUNCTION  unite#handlers#_on_cursor_hold()
Called 2 times
Total time:   0.000265
 Self time:   0.000236

count  total (s)   self (s)
    2              0.000019   let is_async = 0
                            
    2   0.000073   0.000044   call s:restore_statusline()
                            
    2              0.000021   if &filetype ==# 'unite'
                                " Redraw.
                                call unite#redraw()
                            
                                let unite = unite#get_current_unite()
                                let is_async = unite.is_async
                            
                                if !unite.is_async && unite.context.auto_quit
                                  call unite#force_quit_session()
                                endif
                              else
                                " Search other unite window.
    2              0.000051     for winnr in filter(range(1, winnr('$')), "getbufvar(winbufnr(v:val), '&filetype') ==# 'unite'")
                                  let unite = getbufvar(winbufnr(winnr), 'unite')
                                  if unite.is_async
                                    " Redraw unite buffer.
                                    call unite#redraw(winnr)
                            
                                    let is_async = unite.is_async
                                  endif
                                endfor
    2              0.000003   endif
                            
    2              0.000004   if is_async
                                " Ignore key sequences.
                                call feedkeys("g\<ESC>" . (v:count > 0 ? v:count : ''), 'n')
                              endif

FUNCTION  airline#parts#filetype()
Called 297 times
Total time:   0.000649
 Self time:   0.000649

count  total (s)   self (s)
  297              0.000511   return &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>85_BufWritePostHook()
Called 3 times
Total time:   0.493237
 Self time:   0.000135

count  total (s)   self (s)
    3   0.000104   0.000059     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
    3   0.493119   0.000062     call s:UpdateErrors(1, [])

FUNCTION  gitgutter#diff#process_hunk()
Called 21 times
Total time:   0.003393
 Self time:   0.001295

count  total (s)   self (s)
   21              0.000045   let modifications = []
   21              0.000047   let from_line  = a:hunk[0]
   21              0.000041   let from_count = a:hunk[1]
   21              0.000038   let to_line    = a:hunk[2]
   21              0.000037   let to_count   = a:hunk[3]
                            
   21   0.000190   0.000095   if gitgutter#diff#is_added(from_count, to_count)
    9   0.000795   0.000050     call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
    9   0.000086   0.000056     call gitgutter#hunk#increment_lines_added(to_count)
                            
    9              0.000018   elseif gitgutter#diff#is_removed(from_count, to_count)
    6   0.000085   0.000031     call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
    6   0.000044   0.000025     call gitgutter#hunk#increment_lines_removed(from_count)
                            
    6              0.000010   elseif gitgutter#diff#is_modified(from_count, to_count)
    3   0.000093   0.000021     call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
    3   0.000030   0.000018     call gitgutter#hunk#increment_lines_modified(to_count)
                            
    3              0.000007   elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
    3   0.001006   0.000023     call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
    3   0.000042   0.000029     call gitgutter#hunk#increment_lines_added(to_count - from_count)
    3   0.000017   0.000010     call gitgutter#hunk#increment_lines_modified(from_count)
                            
    3              0.000007   elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
   21              0.000020   return modifications

FUNCTION  <SNR>191_get_complete_pos()
Called 262 times
Total time:   0.001120
 Self time:   0.001120

count  total (s)   self (s)
  262              0.000651   if empty(a:complete_results)
  262              0.000244     return -1
                              endif
                            
                              let complete_pos = col('.')
                              for result in values(a:complete_results)
                                if complete_pos > result.complete_pos
                                  let complete_pos = result.complete_pos
                                endif
                              endfor
                            
                              return complete_pos

FUNCTION  gitgutter#sign#remove_signs()
Called 3 times
Total time:   0.000081
 Self time:   0.000077

count  total (s)   self (s)
    3   0.000017   0.000013   let bufnr = gitgutter#utility#bufnr()
    3              0.000010   if a:all_signs && s:supports_star && empty(getbufvar(bufnr, 'gitgutter_other_signs'))
                                let dummy_sign_present = getbufvar(bufnr, 'gitgutter_dummy_sign')
                                execute "sign unplace * buffer=" . bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
                              else
    3              0.000011     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    3              0.000003   endif

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 12 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
   12              0.000036   let s:summary[0] += a:count

FUNCTION  <SNR>23_my_cr_function()
Called 1 time
Total time:   0.000046
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000044   0.000009   return neocomplete#close_popup() . "\<CR>"
                              " For no inserting <CR> key.
                              "return pumvisible() ? neocomplete#close_popup() : "\<CR>"

FUNCTION  <SNR>121_is_excluded_window()
Called 2 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    2              0.000008   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
    8              0.000014   for matchw in g:airline_exclude_filenames
    6              0.000065     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
    6              0.000002   endfor
                            
    2              0.000004   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    2              0.000001   return 0

FUNCTION  300()
Called 3 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    3              0.000042     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  302()
Called 3 times
Total time:   0.002218
 Self time:   0.000815

count  total (s)   self (s)
    3   0.000025   0.000016     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    3   0.000037   0.000013     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   18              0.000027     for type in self._enabled_types
   15              0.000152         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   15   0.000297   0.000123         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   15              0.000045             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    6              0.000027                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    6   0.000281   0.000039                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    6   0.000463   0.000036                     call self._notifier[type].refresh(a:loclist)
    6   0.000065   0.000047                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    6              0.000004                 endif
    6              0.000004             else
    9   0.000551   0.000042                 call self._notifier[type].refresh(a:loclist)
    9              0.000007             endif
   15              0.000007         endif
   15              0.000010     endfor

FUNCTION  303()
Called 3 times
Total time:   0.000822
 Self time:   0.000529

count  total (s)   self (s)
    3   0.000036   0.000015     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   18              0.000026     for type in self._enabled_types
   15              0.000135         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   15              0.000078         if has_key(g:{class}, 'reset')
    9   0.000333   0.000061             call self._notifier[type].reset(a:loclist)
    9              0.000005         endif
                            
                                    " also reset stamps
   15              0.000041         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    6              0.000040             let b:syntastic_private_{type}_stamp = []
    6              0.000005         endif
   15              0.000009     endfor

FUNCTION  307()
Called 3 times
Total time:   0.000331
 Self time:   0.000165

count  total (s)   self (s)
    3   0.000089   0.000028     let ft = s:_normalise_filetype(a:ftalias)
    3   0.000037   0.000016     call self._loadCheckersFor(ft)
                            
    3              0.000010     let checkers_map = self._checkerMap[ft]
    3              0.000006     if empty(checkers_map)
                                    return []
                                endif
                            
    3   0.000064   0.000020     call self._checkDeprecation(ft)
                            
    3              0.000038     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, 0)
                            
    3   0.000066   0.000026     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  airline#extensions#apply()
Called 2 times
Total time:   0.000260
 Self time:   0.000121

count  total (s)   self (s)
    2              0.000007   let s:active_winnr = winnr()
                            
    2   0.000159   0.000020   if s:is_excluded_window()
                                return -1
                              endif
                            
    2              0.000005   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    2              0.000003   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    2              0.000014   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    2              0.000007   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>117__isDebugEnabled_smart()
Called 81 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
   81              0.000318     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>192_uniq()
Called 282 times
Total time:   0.043715
 Self time:   0.001815

count  total (s)   self (s)
  282   0.043529   0.001629   return s:uniq_by(a:list, 'v:val')

FUNCTION  <SNR>192_uniq_by()
Called 282 times
Total time:   0.041900
 Self time:   0.041900

count  total (s)   self (s)
  282              0.005011   let list = map(copy(a:list), printf('[v:val, %s]', a:f))
  282              0.000407   let i = 0
  282              0.000359   let seen = {}
 2603              0.003827   while i < len(list)
 2321              0.007816     let key = string(list[i][1])
 2321              0.004321     if has_key(seen, key)
  489              0.001138       call remove(list, i)
  489              0.000323     else
 1832              0.003226       let seen[key] = 1
 1832              0.001844       let i += 1
 1832              0.000982     endif
 2321              0.001224   endwhile
  282              0.002704   return map(list, 'v:val[0]')

FUNCTION  neocomplete#sources#member#make_cache_current_line()
Called 20 times
Total time:   0.001956
 Self time:   0.000355

count  total (s)   self (s)
   20   0.000253   0.000093   if !neocomplete#is_enabled()
                                call neocomplete#initialize()
                              endif
                            
                              " Make cache from current line.
   20   0.001614   0.000173   return s:make_cache_current_buffer(line('.')-1, line('.')+1)

FUNCTION  syntastic#util#stamp()
Called 9 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    9              0.000032     return reltime(g:_SYNTASTIC_START)

FUNCTION  <SNR>139_AutoUpdate()
Called 5 times
Total time:   0.089641
 Self time:   0.002014

count  total (s)   self (s)
    5   0.000098   0.000048     call s:debug('AutoUpdate called [' . a:fname . ']')
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    5              0.000014     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call s:debug('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    5              0.000157     let bufnr = bufnr(a:fname)
    5              0.000021     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    5              0.000010     if ftype == 'tagbar'
                                    call s:debug('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    5              0.000038     let sftype = get(split(ftype, '\.'), 0, '')
    5   0.000065   0.000034     call s:debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    5   0.000467   0.000037     if !s:IsValidFile(a:fname, sftype)
                                    call s:debug('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
                                endif
                            
    5              0.000009     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    5   0.000053   0.000032     if s:known_files.has(a:fname)
    5   0.000051   0.000021         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    5              0.000049         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
    3   0.000033   0.000015             call s:debug('File data outdated, updating [' . a:fname . ']')
    3   0.085539   0.000075             call s:ProcessFile(a:fname, sftype)
    3              0.000007             let updated = 1
    3              0.000001         else
    2   0.000022   0.000009             call s:debug('File data seems up to date [' . a:fname . ']')
    2              0.000001         endif
    5              0.000010     elseif !s:known_files.has(a:fname)
                                    call s:debug('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
    5   0.000054   0.000027     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    5              0.000009     if empty(fileinfo)
                                    call s:debug('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    5              0.000978     if bufwinnr('__Tagbar__') != -1 && !s:paused && (s:new_window || updated || (!empty(s:known_files.getCurrent(0)) && a:fname != s:known_files.getCurrent(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    5              0.000010     if !empty(fileinfo)
    5   0.000090   0.000048         call s:debug('Setting current file [' . a:fname . ']')
    5   0.000041   0.000022         call s:known_files.setCurrent(fileinfo)
    5              0.000009         let s:nearby_disabled = 0
    5              0.000004     endif
                            
    5   0.001480   0.000031     call s:HighlightTag(0)
    5   0.000065   0.000032     call s:debug('AutoUpdate finished successfully')

FUNCTION  neocomplete#init#_context()
Called 209 times
Total time:   0.002393
 Self time:   0.002393

count  total (s)   self (s)
  209              0.002284   return extend(a:context, { 'input' : '', 'prev_complete_pos' : -1, 'prev_candidates' : [], 'complete_pos' : -1, 'complete_str' : '', 'candidates' : [] })

FUNCTION  313()
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000037     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  314()
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000010     if has_key(self._checkerMap, a:filetype)
    3              0.000003         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  315()
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000018     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  317()
Called 6 times
Total time:   0.000086
 Self time:   0.000039

count  total (s)   self (s)
    6   0.000081   0.000034     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  318()
Called 3 times
Total time:   0.000340
 Self time:   0.000078

count  total (s)   self (s)
    3   0.000038   0.000016     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
    3   0.000045   0.000017     let old_signs = copy(self._bufSignIds())
    3   0.000049   0.000008     if self.enabled()
    3   0.000142   0.000014         call self._signErrors(a:loclist)
    3              0.000002     endif
    3   0.000057   0.000014     call self._removeSigns(old_signs)

FUNCTION  gitgutter#utility#system()
Called 3 times
Total time:   0.040684
 Self time:   0.000869

count  total (s)   self (s)
    3   0.000062   0.000017   if gitgutter#utility#using_xolox_shell()
                                let options = {'command': a:cmd, 'check': 0}
                                if a:0 > 0
                                  let options['stdin'] = a:1
                                endif
                                let ret = xolox#misc#os#exec(options)
                                let output = join(ret.stdout, "\n")
                                let s:exit_code = ret.exit_code
                              else
    3   0.040542   0.000772     silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    3              0.000018   endif
    3              0.000021   return output

FUNCTION  <SNR>197_check_in_do_auto_complete()
Called 279 times
Total time:   0.016299
 Self time:   0.005411

count  total (s)   self (s)
  279   0.011755   0.000867   if neocomplete#is_locked()
                                return 1
                              endif
                            
                              " Detect completefunc.
  279              0.000651   if &l:completefunc != '' && &l:buftype =~ 'nofile'
                                return 1
                              endif
                            
                              " Detect AutoComplPop.
  279              0.000775   if exists('g:acp_enableAtStartup') && g:acp_enableAtStartup
                                call neocomplete#print_error( 'Detected enabled AutoComplPop! Disabled neocomplete.')
                                NeoCompleteLock
                                return 1
                              endif

FUNCTION  neocomplete#handler#_on_moved_i()
Called 136 times
Total time:   0.004919
 Self time:   0.002596

count  total (s)   self (s)
  136   0.001822   0.000721   let neocomplete = neocomplete#get_current_neocomplete()
  136              0.000429   if neocomplete.linenr != line('.')
    1   0.000202   0.000004     call neocomplete#helper#clear_result()
    1              0.000000   endif
  136              0.000321   let neocomplete.linenr = line('.')
                            
  136   0.001568   0.000544   call s:close_preview_window()

FUNCTION  <SNR>139_Init()
Called 55 times
Total time:   0.001687
 Self time:   0.001687

count  total (s)   self (s)
   55              0.000106     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
   55              0.000086     if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
   55              0.000088     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
   55              0.000066     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
   55              0.000063     return 1

FUNCTION  <SNR>166_restore_statusline()
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000018   if &filetype !=# 'unite' || !g:unite_force_overwrite_statusline
    2              0.000004     return
                              endif
                            
                              let unite = unite#get_current_unite()
                            
                              if &l:statusline != unite.statusline
                                " Restore statusline.
                                let &l:statusline = unite.statusline
                              endif

FUNCTION  delimitMate#ParenDelim()
Called 4 times
Total time:   0.001310
 Self time:   0.000432

count  total (s)   self (s)
    4   0.000266   0.000070   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
    4   0.000424   0.000024   if s:is_forbidden(a:right)
                                return left
                              endif
                              " Try to balance matchpairs
    4   0.000070   0.000018   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
                              endif
    4              0.000012   let line = getline('.')
    4              0.000011   let col = col('.')-2
    4   0.000074   0.000019   if s:get('smart_matchpairs') != ''
    4   0.000135   0.000076     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
    4              0.000024     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    4              0.000043     if line[col+1:] =~ smart_matchpairs
                                  return left
                                endif
    4              0.000002   endif
    4   0.000089   0.000025   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
    4   0.000065   0.000013     let tail = s:get('eol_marker')
    4              0.000003   else
                                let tail = ''
                              endif
    4              0.000048   return left . a:right . tail . repeat("\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  320()
Called 3 times
Total time:   0.000128
 Self time:   0.000121

count  total (s)   self (s)
    3              0.000006     let loclist = a:loclist
    3   0.000016   0.000009     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  321()
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000009     if has('signs')
    3              0.000010         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    3              0.000001     endif

FUNCTION  322()
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000015     if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
    3              0.000004     return b:syntastic_private_sign_ids

FUNCTION  329()
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000021   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>139_SortTags()
Called 6 times
Total time:   0.005798
 Self time:   0.000575

count  total (s)   self (s)
    6   0.002613   0.000326     call sort(a:tags, a:comparemethod)
                            
   51              0.000049     for tag in a:tags
   45              0.000075         if has_key(tag, 'children')
    3              0.000016             call s:SortTags(tag.children, a:comparemethod)
    3              0.000002         endif
   45              0.000017     endfor

FUNCTION  <SNR>41_is_forbidden()
Called 5 times
Total time:   0.000507
 Self time:   0.000094

count  total (s)   self (s)
    5   0.000108   0.000028   if !s:get('excluded_regions_enabled')
                                return 0
                              endif
    5   0.000279   0.000023   let region = s:get_syn_name()
    5   0.000105   0.000028   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  gitgutter#sign#next_sign_id()
Called 14 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   14              0.000034   let next_id = s:next_sign_id
   14              0.000027   let s:next_sign_id += 1
   14              0.000011   return next_id

FUNCTION  <SNR>83__normalise_filetype()
Called 3 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    3              0.000017     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    3              0.000012     let ft = get(g:syntastic_filetype_map, ft, ft)
    3              0.000019     let ft = substitute(ft, '\m-', '_', 'g')
    3              0.000005     return ft

FUNCTION  331()
Called 11 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   11              0.000076   call add(self._sections, [a:group, a:contents])

FUNCTION  332()
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000016   call add(self._sections, ['', a:text])

FUNCTION  333()
Called 2 times
Total time:   0.008670
 Self time:   0.001158

count  total (s)   self (s)
    2              0.000006   let side = 1
    2              0.000004   let line = ''
    2              0.000004   let i = 0
    2              0.000008   let length = len(self._sections)
    2              0.000004   let split = 0
                            
   17              0.000028   while i < length
   15              0.000051     let section = self._sections[i]
   15              0.000047     let group = section[0]
   15              0.000046     let contents = section[1]
   15   0.000375   0.000106     let prev_group = s:get_prev_group(self._sections, i)
                            
   15              0.000029     if group == ''
    2              0.000007       let line .= contents
    2              0.000003     elseif group == '|'
    2              0.000003       let side = 0
    2              0.000009       let line .= contents
    2              0.000003       let split = 1
    2              0.000002     else
   11              0.000046       if prev_group == ''
    2              0.000008         let line .= '%#'.group.'#'
    2              0.000002       elseif split
    2   0.000883   0.000030         let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    2              0.000005         let split = 0
    2              0.000002       else
    7   0.005796   0.000074         let line .= s:get_seperator(self, prev_group, group, side)
    7              0.000008       endif
   11   0.000798   0.000130       let line .= s:get_accented_line(self, group, contents)
   11              0.000012     endif
                            
   15              0.000044     let i = i + 1
   15              0.000015   endwhile
                            
    2              0.000003   if !self._context.active
    1              0.000032     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    1              0.000001   endif
    2              0.000002   return line

FUNCTION  336()
Called 45 times
Total time:   0.002070
 Self time:   0.000879

count  total (s)   self (s)
   45              0.000540     let newobj = copy(self)
                            
   45   0.001418   0.000227     call newobj._init(a:name)
                            
   45              0.000051     return newobj

FUNCTION  337()
Called 45 times
Total time:   0.001191
 Self time:   0.001191

count  total (s)   self (s)
   45              0.000137     let self.name          = a:name
   45              0.000084     let self.fields        = {}
   45              0.000077     let self.fields.line   = 0
   45              0.000063     let self.fields.column = 1
   45              0.000097     let self.prototype     = ''
   45              0.000082     let self.path          = ''
   45              0.000090     let self.fullpath      = a:name
   45              0.000075     let self.depth         = 0
   45              0.000095     let self.parent        = {}
   45              0.000069     let self.tline         = -1
   45              0.000099     let self.fileinfo      = {}
   45              0.000104     let self.typeinfo      = {}

FUNCTION  <SNR>85_UpdateErrors()
Called 3 times
Total time:   0.493057
 Self time:   0.000506

count  total (s)   self (s)
    3   0.000074   0.000038     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    3   0.000056   0.000028     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
    3   0.000039   0.000013     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    3   0.000043   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    3   0.000385   0.000019     if s:_skip_file()
                                    return
                                endif
                            
    3   0.000092   0.000024     call s:modemap.synch()
    3   0.000216   0.000020     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
    3              0.000005     if run_checks
    3   0.489616   0.000110         call s:CacheErrors(a:checker_names)
    3              0.000005     endif
                            
    3   0.000065   0.000026     let loclist = g:SyntasticLoclist.current()
                            
    3              0.000009     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    3   0.000039   0.000013     let do_jump = syntastic#util#var('auto_jump') + 0
    3              0.000005     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    3              0.000011     let w:syntastic_loclist_set = 0
    3   0.000035   0.000012     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.getRaw())
                                    let w:syntastic_loclist_set = 1
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
    3   0.002243   0.000025     call s:notifiers.refresh(loclist)

FUNCTION  343()
Called 45 times
Total time:   0.001357
 Self time:   0.001187

count  total (s)   self (s)
   45              0.000093     let fileinfo = self.fileinfo
                            
   45   0.000591   0.000421     if s:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
   43              0.000229         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
   43              0.000067     elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
    2              0.000012         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
    2              0.000001     endif

FUNCTION  neocomplete#is_enabled()
Called 590 times
Total time:   0.003978
 Self time:   0.002568

count  total (s)   self (s)
  590   0.003673   0.002263   return neocomplete#init#is_enabled()

FUNCTION  gitgutter#diff#is_modified()
Called 6 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    6              0.000017   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  gitgutter#diff#process_hunks()
Called 3 times
Total time:   0.003696
 Self time:   0.000277

count  total (s)   self (s)
    3   0.000041   0.000015   call gitgutter#hunk#reset()
    3              0.000005   let modified_lines = []
   24              0.000031   for hunk in a:hunks
   21   0.003579   0.000186     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
   21              0.000014   endfor
    3              0.000003   return modified_lines

FUNCTION  353()
Called 55 times
Total time:   0.000918
 Self time:   0.000918

count  total (s)   self (s)
   55              0.000087     if a:full && self.path != ''
                                    let str = self.path . self.typeinfo.sro . self.name
                                else
   55              0.000095         let str = self.name
   55              0.000032     endif
                            
   55              0.000122     if has_key(self.fields, 'signature')
   28              0.000029         if a:longsig
                                        let str .= self.fields.signature
                                    else
   28              0.000056             let str .= '()'
   28              0.000018         endif
   28              0.000011     endif
                            
   55              0.000044     return str

FUNCTION  gitgutter#utility#filename()
Called 3 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    3              0.000009   return fnamemodify(s:file, ':t')

FUNCTION  UltiSnips#CursorMoved()
Called 188 times
Total time:   0.029752
 Self time:   0.029752

count  total (s)   self (s)
  188              0.029491     exec g:_uspy "UltiSnips_Manager._cursor_moved()"

FUNCTION  <SNR>139_ExecuteCtagsOnFile()
Called 3 times
Total time:   0.050529
 Self time:   0.000785

count  total (s)   self (s)
    3   0.000074   0.000031     call s:debug('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
    3              0.000014     if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
                                elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
                                else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
    3              0.000015         let ctags_args  = [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSaf', '--extra=', '--sort=no', '--append=no' ]
                            
                                    " Include extra type definitions
    3              0.000011         if has_key(a:typeinfo, 'deffile')
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
                                    endif
                            
                                    " Third-party programs may not necessarily make use of this
    3              0.000006         if has_key(a:typeinfo, 'ctagstype')
    3              0.000028             let ctags_type = a:typeinfo.ctagstype
                            
    3              0.000005             let ctags_kinds = ''
   39              0.000031             for kind in a:typeinfo.kinds
   36              0.000068                 let ctags_kinds .= kind.short
   36              0.000023             endfor
                            
    3              0.000012             let ctags_args += ['--language-force=' . ctags_type]
    3              0.000012             let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
    3              0.000002         endif
    3              0.000003     endif
                            
    3              0.000007     if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
                                else
    3              0.000006         let ctags_bin = g:tagbar_ctags_bin
    3              0.000002     endif
                            
    3   0.000707   0.000034     let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
    3              0.000005     if ctags_cmd == ''
                                    return ''
                                endif
                            
    3   0.049074   0.000087     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    3              0.000067     if v:shell_error || ctags_output =~ 'Warning: cannot open source file'
                                    call s:debug('Command output:')
                                    call s:debug(ctags_output)
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr("__Tagbar__") != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                        call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                    endif
                                    return -1
                                endif
                            
    3   0.000078   0.000037     call s:debug('Ctags executed successfully')
    3              0.000010     return ctags_output

FUNCTION  airline#extensions#default#apply()
Called 2 times
Total time:   0.001682
 Self time:   0.000208

count  total (s)   self (s)
    2              0.000006   let winnr = a:context.winnr
    2              0.000004   let active = a:context.active
                            
    2   0.000026   0.000014   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    1   0.000163   0.000005     call s:build_sections(a:builder, a:context, s:layout[0])
    1              0.000001   else
    1   0.000071   0.000017     let text = s:get_section(winnr, 'c')
    1              0.000003     if empty(text)
                                  let text = ' %f%m '
                                endif
    1   0.000022   0.000011     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    1              0.000002   endif
                            
    2   0.000222   0.000052   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    2   0.000023   0.000013   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    2   0.001104   0.000045     call s:build_sections(a:builder, a:context, s:layout[1])
    2              0.000004   endif
                            
    2              0.000002   return 1

FUNCTION  365()
Called 55 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
   55              0.000178     let idx = self.kinddict[a:kind]
   55              0.000124     return self.kinds[idx]

FUNCTION  368()
Called 3 times
Total time:   0.000480
 Self time:   0.000480

count  total (s)   self (s)
    3              0.000027     let self.mtime = getftime(self.fpath)
    3              0.000034     let self.tags  = []
    3              0.000156     let self.fline = {}
    3              0.000021     let self.tline = {}
                            
    3              0.000013     let self._tagfolds_old = self.tagfolds
    3              0.000009     let self.tagfolds = {}
                            
   39              0.000043     for kind in self.typeinfo.kinds
   36              0.000112         let self.tagfolds[kind.short] = {}
   36              0.000029     endfor

FUNCTION  369()
Called 3 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
    3              0.000009     if exists('self._tagfolds_old')
    3              0.000153         unlet self._tagfolds_old
    3              0.000003     endif

FUNCTION  neocomplete#close_popup()
Called 1 time
Total time:   0.000035
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000034   0.000007   return neocomplete#mappings#close_popup()

FUNCTION  <SNR>191_get_omni_funcs()
Called 262 times
Total time:   0.040955
 Self time:   0.028626

count  total (s)   self (s)
  262              0.000497   let funcs = []
  786              0.002423   for ft in insert(split(a:filetype, '\.'), '_')
  524   0.005986   0.003733     let omnifuncs = neocomplete#util#convert2list( get(g:neocomplete#sources#omni#functions, ft, &l:omnifunc))
                            
 1048              0.001279     for omnifunc in omnifuncs
  524   0.003704   0.001909       if neocomplete#helper#check_invalid_omnifunc(omnifunc)
                                    " omnifunc is irregal.
  524              0.000540         continue
                                  endif
                            
                                  if get(g:neocomplete#sources#omni#input_patterns, omnifunc, '') != ''
                                    let pattern = g:neocomplete#sources#omni#input_patterns[omnifunc]
                                  elseif get(g:neocomplete#sources#omni#input_patterns, ft, '') != ''
                                    let pattern = g:neocomplete#sources#omni#input_patterns[ft]
                                  else
                                    let pattern = ''
                                  endif
                            
                                  if pattern == ''
                                    continue
                                  endif
                            
                                  call add(funcs, [omnifunc, pattern])
                                endfor
  524              0.000339   endfor
                            
  262   0.009570   0.001289   return s:List.uniq(funcs)

FUNCTION  <SNR>137_load()
Called 66 times
Total time:   0.002612
 Self time:   0.002612

count  total (s)   self (s)
   66              0.002413   if !filereadable(g:unite_source_history_yank_file)  || s:yank_histories_file_mtime == getftime(g:unite_source_history_yank_file)
   66              0.000104     return
                              endif
                            
                              let file = readfile(g:unite_source_history_yank_file)
                              if empty(file)
                                return
                              endif
                            
                              try
                                sandbox let s:yank_histories = eval(file[0])
                            
                                " Type check.
                                let history = s:yank_histories[0]
                                let history[0] = history[0]
                              catch
                                let s:yank_histories = []
                              endtry
                            
                              let s:yank_histories_file_mtime = getftime(g:unite_source_history_yank_file)
                            
                              let s:yank_histories = unite#util#uniq(s:yank_histories)

FUNCTION  <SNR>139_ExecuteCtags()
Called 3 times
Total time:   0.048987
 Self time:   0.001115

count  total (s)   self (s)
    3   0.000034   0.000016     call s:debug('Executing ctags command: ' . a:ctags_cmd)
                            
    3              0.000015     if &shell =~# 'fish$'
                                    " Reset shell since fish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
                                endif
                            
    3              0.000006     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
    3              0.000010     if &shell =~ 'cmd\.exe'
                                    let shellxquote_save = &shellxquote
                                    set shellxquote=\"
                                    let shellcmdflag_save = &shellcmdflag
                                    set shellcmdflag=/s\ /c
                                endif
                            
    3              0.000001     if s:debug
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call s:debug(v:statusmsg)
                                    redraw!
                                else
    3   0.048640   0.000786         let ctags_output = system(a:ctags_cmd)
    3              0.000021     endif
                            
    3              0.000093     if &shell =~ 'cmd\.exe'
                                    let &shellxquote  = shellxquote_save
                                    let &shellcmdflag = shellcmdflag_save
                                endif
                            
    3              0.000013     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
    3              0.000007     if exists('shell_save')
                                    let &shell = shell_save
                                endif
                            
    3              0.000018     return ctags_output

FUNCTION  airline#highlighter#add_separator()
Called 9 times
Total time:   0.003797
 Self time:   0.000223

count  total (s)   self (s)
    9              0.000095   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
    9   0.003695   0.000121   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#util#wrap()
Called 1975 times
Total time:   0.009766
 Self time:   0.009766

count  total (s)   self (s)
 1975              0.004168   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1975              0.001814   return a:text

FUNCTION  370()
Called 3 times
Total time:   0.002980
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000011     if get(s:compare_typeinfo, 'sort', g:tagbar_sort)
    3   0.002955   0.000019         call s:SortTags(self.tags, 's:CompareByKind')
    3              0.000001     else
                                    call s:SortTags(self.tags, 's:CompareByLine')
                                endif

FUNCTION  373()
Called 60 times
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
   60              0.000095     if !s:paused || a:forcecurrent
   60              0.000096         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  374()
Called 5 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    5              0.000013     let self._current = a:fileinfo

FUNCTION  376()
Called 19 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   19              0.000067     return get(self._files, a:fname, {})

FUNCTION  378()
Called 53 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
   53              0.000165     return has_key(self._files, a:fname)

FUNCTION  airline#extensions#tagbar#inactive_apply()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000008   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
                                return -1
                              endif

FUNCTION  neocomplete#helper#check_invalid_omnifunc()
Called 803 times
Total time:   0.002838
 Self time:   0.002838

count  total (s)   self (s)
  803              0.002437   return a:omnifunc == '' || (a:omnifunc !~ '#' && !exists('*' . a:omnifunc))

FUNCTION  gitgutter#utility#set_buffer()
Called 5 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    5              0.000020   let s:bufnr = a:bufnr
    5              0.000075   let s:file = resolve(bufname(a:bufnr))

FUNCTION  syntastic#util#system()
Called 3 times
Total time:   0.480736
 Self time:   0.000992

count  total (s)   self (s)
    3              0.000011     let old_shell = &shell
    3              0.000014     let old_lc_messages = $LC_MESSAGES
    3              0.000005     let old_lc_all = $LC_ALL
                            
    3   0.000047   0.000021     let &shell = syntastic#util#var('shell')
    3              0.000013     let $LC_MESSAGES = 'C'
    3              0.000005     let $LC_ALL = ''
                            
    3   0.480437   0.000719     let out = system(a:command)
                            
    3              0.000037     let $LC_ALL = old_lc_all
    3              0.000013     let $LC_MESSAGES = old_lc_messages
                            
    3              0.000061     let &shell = old_shell
                            
    3              0.000033     return out

FUNCTION  neocomplete#sources#buffer#make_cache_current_line()
Called 20 times
Total time:   0.059215
 Self time:   0.000291

count  total (s)   self (s)
                              " let start = reltime()
   20   0.059168   0.000244   call s:make_cache_current_buffer( max([1, line('.')-10]), min([line('$'), line('.') + 10]))
                              " echomsg reltimestr(reltime(start))

FUNCTION  <SNR>134_get_prev_group()
Called 15 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
   15              0.000042   let x = a:i - 1
   18              0.000031   while x >= 0
   16              0.000059     let group = a:sections[x][0]
   16              0.000045     if group != '' && group != '|'
   13              0.000020       return group
                                endif
    3              0.000007     let x = x - 1
    3              0.000003   endwhile
    2              0.000002   return ''

FUNCTION  <SNR>190_make_cache_lines()
Called 20 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   20              0.000042   let filetype = a:filetype
   20              0.000072   if get(g:neocomplete#sources#member#prefix_patterns, filetype, '') == ''
   20              0.000017     return
                              endif
                            
                              if !has_key(s:member_sources, a:srcname)
                                call s:initialize_source(a:srcname, filetype)
                              endif
                            
                              let source = s:member_sources[a:srcname]
                              let member_pattern = s:get_member_pattern(filetype)
                              let prefix_pattern = member_pattern . '\m\%(' . g:neocomplete#sources#member#prefix_patterns[filetype] . '\m\)'
                              let keyword_pattern = prefix_pattern . member_pattern
                            
                              " Cache member pattern.
                              for line in a:lines
                                let match = match(line, keyword_pattern)
                            
                                while match >= 0 "{{{
                                  let match_str = matchstr(line, '^'.keyword_pattern, match)
                            
                                  " Next match.
                                  let match = matchend(line, prefix_pattern, match)
                            
                                  let member_name = matchstr(match_str, member_pattern . '$')
                                  if member_name == ''
                                    continue
                                  endif
                                  let var_name = match_str[ : -len(member_name)-1]
                            
                                  if !has_key(source.member_cache, var_name)
                                    let source.member_cache[var_name] = {}
                                  endif
                                  if !has_key(source.member_cache[var_name], member_name)
                                    let source.member_cache[var_name][member_name] = 1
                                  endif
                            
                                  let match_str = matchstr(var_name, '^'.keyword_pattern)
                                endwhile"}}}
                              endfor

FUNCTION  <SNR>125_get_hunks_gitgutter()
Called 270 times
Total time:   0.006001
 Self time:   0.002857

count  total (s)   self (s)
  270   0.003004   0.001473   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  270   0.002443   0.000830   return GitGutterGetHunkSummary()

FUNCTION  <SNR>197_close_preview_window()
Called 148 times
Total time:   0.001117
 Self time:   0.001117

count  total (s)   self (s)
  148              0.000751   if g:neocomplete#enable_auto_close_preview && bufname('%') !=# '[Command Line]' && winnr('$') != 1 && !&l:previewwindow && !s:check_in_do_auto_complete()
                                " Close preview window.
                                pclose!
                              endif

FUNCTION  <SNR>134_get_seperator()
Called 7 times
Total time:   0.005722
 Self time:   0.000137

count  total (s)   self (s)
    7   0.002446   0.000069   if s:should_change_group(a:prev_group, a:group)
    7   0.003269   0.000061     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>41_get_syn_name()
Called 5 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
    5              0.000018   let col = col('.')
    5              0.000011   if  col == col('$')
    4              0.000007     let col = col - 1
    4              0.000002   endif
    5              0.000209   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  syntastic#log#debugShowVariables()
Called 6 times
Total time:   0.000070
 Self time:   0.000047

count  total (s)   self (s)
    6   0.000055   0.000032     if !s:_isDebugEnabled(a:level)
    6              0.000005         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>139_HighlightTag()
Called 5 times
Total time:   0.001449
 Self time:   0.000125

count  total (s)   self (s)
    5              0.000012     let tagline = 0
                            
    5              0.000010     let force = a:0 > 0 ? a:1 : 0
                            
    5              0.000005     if a:0 > 1
                                    let tag = s:GetNearbyTag(1, 0, a:2)
                                else
    5   0.001348   0.000024         let tag = s:GetNearbyTag(1, 0)
    5              0.000005     endif
    5              0.000008     if !empty(tag)
    5              0.000007         let tagline = tag.tline
    5              0.000002     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    5              0.000011     if !force && tagline == s:last_highlight_tline
    5              0.000003         return
                                else
                                    let s:last_highlight_tline = tagline
                                endif
                            
                                let tagbarwinnr = bufwinnr('__Tagbar__')
                                if tagbarwinnr == -1
                                    return
                                endif
                                let prevwinnr = winnr()
                                call s:goto_win(tagbarwinnr)
                            
                                match none
                            
                                " No tag above cursor position so don't do anything
                                if tagline == 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                if g:tagbar_autoshowtag == 1 || a:openfolds
                                    call s:OpenParents(tag)
                                endif
                            
                                " Check whether the tag is inside a closed fold and highlight the parent
                                " instead in that case
                                let tagline = tag.getClosedParentTline()
                            
                                " Parent tag line number is invalid, better don't do anything
                                if tagline <= 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                " Go to the line containing the tag
                                execute tagline
                            
                                " Make sure the tag is visible in the window
                                call winline()
                            
                                let foldpat = '[' . s:icon_open . s:icon_closed . ' ]'
                                let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\zs[^( ]\+\ze/'
                                call s:debug("Highlight pattern: '" . pattern . "'")
                                if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                    execute 'match TagbarHighlight ' . pattern
                                else
                                    execute 'match Search ' . pattern
                                endif
                            
                            
                                if a:0 <= 1 " no line explicitly given, so assume we were in the file window
                                    call s:goto_win(prevwinnr)
                                endif
                            
                                redraw

FUNCTION  <SNR>85__ignore_file()
Called 6 times
Total time:   0.000356
 Self time:   0.000356

count  total (s)   self (s)
    6              0.000276     let fname = fnamemodify(a:filename, ':p')
    6              0.000026     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    6              0.000005     return 0

FUNCTION  neocomplete#handler#_on_insert_leave()
Called 12 times
Total time:   0.044056
 Self time:   0.000414

count  total (s)   self (s)
   12   0.004184   0.000107   call neocomplete#helper#clear_result()
                            
   12   0.000159   0.000066   call s:close_preview_window()
   12   0.039448   0.000047   call s:make_cache_current_line()
                            
   12   0.000114   0.000043   let neocomplete = neocomplete#get_current_neocomplete()
   12              0.000023   let neocomplete.cur_text = ''
   12              0.000023   let neocomplete.completed_item = {}
   12              0.000021   let neocomplete.overlapped_items = {}

FUNCTION  airline#util#getwinvar()
Called 14 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
   14              0.000081     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  neocomplete#is_eskk_enabled()
Called 541 times
Total time:   0.002129
 Self time:   0.002129

count  total (s)   self (s)
  541              0.001883   return exists('*eskk#is_enabled') && eskk#is_enabled()

FUNCTION  neocomplete#mappings#close_popup()
Called 1 time
Total time:   0.000027
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000018   0.000008   let neocomplete = neocomplete#get_current_neocomplete()
    1              0.000002   let neocomplete.complete_str = ''
    1              0.000002   let neocomplete.skip_next_complete = 2
                            
    1              0.000002   return pumvisible() ? "\<C-y>" : ''

FUNCTION  gitgutter#diff#process_removed()
Called 6 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    6              0.000007   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
    6              0.000021     call add(a:modifications, [a:to_line, 'removed'])
    6              0.000005   endif

FUNCTION  <SNR>130_exec_separator()
Called 621 times
Total time:   0.182148
 Self time:   0.020422

count  total (s)   self (s)
  621   0.076727   0.003294   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  621   0.070730   0.003229   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  621              0.002082   let group = a:from.'_to_'.a:to.a:suffix
  621              0.000656   if a:inverse
  104              0.000463     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  104              0.000081   else
  517              0.002316     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  517              0.000363   endif
  621              0.002557   let a:dict[group] = colors
  621   0.023570   0.002778   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>85_ClearCache()
Called 3 times
Total time:   0.001244
 Self time:   0.000213

count  total (s)   self (s)
    3   0.000893   0.000037     call s:notifiers.reset(g:SyntasticLoclist.current())
    3   0.000344   0.000169     call b:syntastic_loclist.destroy()

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000015   let s:summary[1] += a:count

FUNCTION  <SNR>134_get_accented_line()
Called 11 times
Total time:   0.000668
 Self time:   0.000668

count  total (s)   self (s)
   11              0.000027   if a:self._context.active
    7              0.000017     let contents = []
    7              0.000072     let content_parts = split(a:contents, '__accent')
   12              0.000025     for cpart in content_parts
    5              0.000065       let accent = matchstr(cpart, '_\zs[^#]*\ze')
    5              0.000016       call add(contents, cpart)
    5              0.000008     endfor
    7              0.000028     let line = join(contents, a:group)
    7              0.000074     let line = substitute(line, '__restore__', a:group, 'g')
    7              0.000008   else
    4              0.000079     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
    4              0.000044     let line = substitute(line, '%#__restore__#', '', 'g')
    4              0.000005   endif
   11              0.000017   return line

FUNCTION  gitgutter#diff#process_modified_and_added()
Called 3 times
Total time:   0.000983
 Self time:   0.000983

count  total (s)   self (s)
    3              0.000006   let offset = 0
    9              0.000016   while offset < a:from_count
    6              0.000018     let line_number = a:to_line + offset
    6              0.000027     call add(a:modifications, [line_number, 'modified'])
    6              0.000010     let offset += 1
    6              0.000008   endwhile
   69              0.000081   while offset < a:to_count
   66              0.000141     let line_number = a:to_line + offset
   66              0.000395     call add(a:modifications, [line_number, 'added'])
   66              0.000127     let offset += 1
   66              0.000081   endwhile

FUNCTION  syntastic#util#var()
Called 66 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
   66              0.000496     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  <SNR>85__resolve_filetypes()
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000019     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
    3              0.000036     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  <SNR>171_get_list()
Called 20 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
   20              0.000069   if !exists('s:List')
                                let s:List = neocomplete#util#get_vital().import('Data.List')
                              endif
   20              0.000018   return s:List

FUNCTION  <SNR>197_make_cache_current_line()
Called 20 times
Total time:   0.067046
 Self time:   0.000682

count  total (s)   self (s)
   20   0.000209   0.000082   let neocomplete = neocomplete#get_current_neocomplete()
   20   0.002570   0.000110   if neocomplete#helper#is_enabled_source('buffer', neocomplete.context_filetype)
                                " Caching current cache line.
   20   0.059317   0.000102     call neocomplete#sources#buffer#make_cache_current_line()
   20              0.000024   endif
   20   0.002762   0.000156   if neocomplete#helper#is_enabled_source('member', neocomplete.context_filetype)
                                " Caching current cache line.
   20   0.002091   0.000135     call neocomplete#sources#member#make_cache_current_line()
   20              0.000013   endif

FUNCTION  <SNR>40_TriggerAbb()
Called 5 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    5              0.000074   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
                                return ''
                              endif
    5              0.000019   return "\<C-]>"

FUNCTION  <SNR>85__add_to_errors()
Called 3 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    6              0.000011     for err in a:errors
    6              0.000012         for key in keys(a:options)
    3              0.000020             if !has_key(err, key) || empty(err[key])
    3              0.000009                 let err[key] = a:options[key]
    3              0.000006             endif
    3              0.000002         endfor
    3              0.000003     endfor
                            
    3              0.000006     return a:errors

FUNCTION  <SNR>85__skip_file()
Called 6 times
Total time:   0.000710
 Self time:   0.000354

count  total (s)   self (s)
    6              0.000026     let fname = expand('%', 1)
    6   0.000639   0.000283     let skip = get(b:, 'syntastic_skip_checks', 0) || (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    6              0.000009     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    6              0.000003     return skip

FUNCTION  unite#util#substitute_path_separator()
Called 6 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    6              0.000008     return a:path

FUNCTION  airline#highlighter#highlight()
Called 27 times
Total time:   0.362901
 Self time:   0.098110

count  total (s)   self (s)
   27              0.000117   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   27              0.000293   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   27              0.000095   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   78              0.000145   for mode in mapped
   51              0.000304     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   51              0.000186       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  900              0.001955       for kvp in items(dict)
  849              0.002083         let mode_colors = kvp[1]
  849   0.033701   0.004627         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
 2547              0.004569         for accent in keys(s:accents)
 1698              0.003799           if !has_key(p.accents, accent)
                                        continue
                                      endif
 1698              0.005973           let colors = copy(mode_colors)
 1698              0.004584           if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
                                      endif
 1698              0.003807           if p.accents[accent][2] != ''
  849              0.002520             let colors[2] = p.accents[accent][2]
  849              0.000597           endif
 1698              0.002589           if len(colors) >= 5
  372              0.001271             let colors[4] = get(p.accents[accent], 4, '')
  372              0.000284           else
 1326              0.004579             call add(colors, get(p.accents[accent], 4, ''))
 1326              0.000802           endif
 1698   0.067140   0.009997           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
 1698              0.001656         endfor
  849              0.000508       endfor
                            
                                  " TODO: optimize this
  663              0.001538       for sep in items(s:separators)
  612   0.184793   0.006219         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  612              0.000688       endfor
   51              0.000024     endif
   51              0.000031   endfor

FUNCTION  gitgutter#diff#process_added()
Called 9 times
Total time:   0.000745
 Self time:   0.000745

count  total (s)   self (s)
    9              0.000018   let offset = 0
   72              0.000081   while offset < a:to_count
   63              0.000128     let line_number = a:to_line + offset
   63              0.000268     call add(a:modifications, [line_number, 'added'])
   63              0.000111     let offset += 1
   63              0.000064   endwhile

FUNCTION  <SNR>179_should_create_cache()
Called 20 times
Total time:   0.001499
 Self time:   0.001499

count  total (s)   self (s)
   20              0.001148   let filepath = fnamemodify(bufname(a:bufnr), ':p')
   20              0.000334   return getfsize(filepath) < g:neocomplete#sources#buffer#cache_limit_size && getbufvar(a:bufnr, '&modifiable') && !getwinvar(bufwinnr(a:bufnr), '&previewwindow') && (g:neocomplete#sources#buffer#disabled_pattern == ''  || filepath !~# g:neocomplete#sources#buffer#disabled_pattern)

FUNCTION  airline#parts#ffenc()
Called 297 times
Total time:   0.003460
 Self time:   0.003460

count  total (s)   self (s)
  297              0.003302   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  377()
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000005     if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
                                else
    3              0.000006         let fname = a:fileinfo.fpath
    3              0.000016         let self._files[fname] = a:fileinfo
    3              0.000002     endif

FUNCTION  gitgutter#utility#shellescape()
Called 6 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    6              0.000055   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    6              0.000009     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 3 times
Total time:   0.012230
 Self time:   0.011641

count  total (s)   self (s)
    3   0.000021   0.000015   let bufnr = gitgutter#utility#bufnr()
    3              0.000012   let other_signs         = getbufvar(bufnr, 'gitgutter_other_signs')
    3              0.000008   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
                            
  147              0.000131   for line in a:modified_lines
  144              0.000280     let line_number = line[0]  " <number>
  144              0.000290     if index(other_signs, line_number) == -1  " don't clobber others' signs
  144   0.001139   0.000642       let name = gitgutter#utility#highlight_name_for_change(line[1])
  144              0.000349       if !has_key(old_gitgutter_signs, line_number)  " insert
   14   0.000142   0.000056         let id = gitgutter#sign#next_sign_id()
   14              0.008167         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
   14              0.000044       else  " update if sign has changed
  130              0.000310         let old_sign = old_gitgutter_signs[line_number]
  130              0.000200         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
  130              0.000047       endif
  144              0.000051     endif
  144              0.000081   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  syntastic#log#debugDump()
Called 3 times
Total time:   0.000026
 Self time:   0.000019

count  total (s)   self (s)
    3   0.000018   0.000011     if !s:_isDebugEnabled(a:level)
    3              0.000001         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  tagbar#currenttag()
Called 55 times
Total time:   0.015981
 Self time:   0.002868

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   55              0.000135     let s:statusline_in_use = 1
                            
   55              0.000058     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   55              0.000443         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   55              0.000172         let fullpath  = a:1 =~# 'f'
   55              0.000159         let prototype = a:1 =~# 'p'
   55              0.000040     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   55   0.001925   0.000238     if !s:Init(1)
                                    return a:default
                                endif
                            
   55   0.010800   0.000292     let tag = s:GetNearbyTag(0, 1)
                            
   55              0.000089     if !empty(tag)
   55              0.000051         if prototype
                                        return tag.getPrototype(1)
                                    else
   55   0.001285   0.000367             return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  <SNR>41_get()
Called 40 times
Total time:   0.000669
 Self time:   0.000669

count  total (s)   self (s)
   40              0.000060   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
                                let bufoptions = get(s:options, bufnr('%'), {})
                                return deepcopy(get(bufoptions, a:name, a:1))
                              else
   40              0.000279     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  gitgutter#diff#parse_hunk()
Called 21 times
Total time:   0.001257
 Self time:   0.001257

count  total (s)   self (s)
   21              0.000539   let matches = matchlist(a:line, s:hunk_re)
   21              0.000094   if len(matches) > 0
   21              0.000097     let from_line  = str2nr(matches[1])
   21              0.000137     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   21              0.000072     let to_line    = str2nr(matches[3])
   21              0.000097     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   21              0.000149     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  neocomplete#is_text_mode()
Called 302 times
Total time:   0.004893
 Self time:   0.002649

count  total (s)   self (s)
  302   0.003613   0.001369   let neocomplete = neocomplete#get_current_neocomplete()
  302              0.001042   return get(g:neocomplete#text_mode_filetypes, neocomplete.context_filetype, 0)

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010   return getbufvar(s:bufnr, 'changedtick') != getbufvar(s:bufnr, 'gitgutter_last_tick')

FUNCTION  <SNR>134_should_change_group()
Called 7 times
Total time:   0.002377
 Self time:   0.000243

count  total (s)   self (s)
    7              0.000018   if a:group1 == a:group2
                                return 0
                              endif
    7   0.001133   0.000043   let color1 = airline#highlighter#get_highlight(a:group1)
    7   0.001084   0.000040   let color2 = airline#highlighter#get_highlight(a:group2)
    7              0.000052   if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
    7              0.000032     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>134_get_transitioned_seperator()
Called 9 times
Total time:   0.004061
 Self time:   0.000264

count  total (s)   self (s)
    9              0.000023   let line = ''
    9   0.003864   0.000067   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
    9              0.000063   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
    9              0.000046   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
    9              0.000035   let line .= '%#'.a:group.'#'
    9              0.000015   return line

FUNCTION  <SNR>179_make_cache_current_buffer()
Called 20 times
Total time:   0.058924
 Self time:   0.020925

count  total (s)   self (s)
   20              0.000064   let srcname = bufnr('%')
                            
                              " Make cache from current buffer.
   20   0.001595   0.000096   if !s:should_create_cache(srcname)
                                return
                              endif
                            
   20   0.000734   0.000094   if !s:exists_current_source()
                                call s:initialize_source(srcname)
                              endif
                            
   20              0.000061   let source = s:buffer_sources[srcname]
   20              0.000048   let keyword_pattern = source.keyword_pattern
   20              0.000032   if keyword_pattern == ''
                                return
                              endif
                            
   20              0.000027   let words = []
                            
   20              0.000024   lua << EOF
                            do
                              local words = vim.eval('words')
                              local dup = {}
                              local b = vim.buffer()
                              local min_length = vim.eval('g:neocomplete#min_keyword_length')
                              for linenr = vim.eval('a:start'), vim.eval('a:end') do
                                local match = 0
                                while 1 do
                                  local match_str = vim.eval('matchstr(getline('..linenr..
                                  '), keyword_pattern, ' .. match .. ')')
                                  if match_str == '' then
                                    break
                                  end
                                  if dup[match_str] == nil
                                    and string.len(match_str) >= min_length then
                                    dup[match_str] = 1
                                    words:add(match_str)
                                  end
                            
                                  -- Next match.
                                  match = vim.eval('matchend(getline(' .. linenr ..
                                    '), keyword_pattern, ' .. match .. ')')
                                end
                              end
                            end
                            EOF
                            
   20   0.037809   0.001949   let source.words = neocomplete#util#uniq(source.words + words)

FUNCTION  neocomplete#handler#_on_text_changed()
Called 135 times
Total time:   0.129255
 Self time:   0.016149

count  total (s)   self (s)
  135   0.006390   0.000617   if neocomplete#is_cache_disabled()
                                return
                              endif
                            
  135   0.001421   0.000553   let neocomplete = neocomplete#get_current_neocomplete()
                            
  135              0.000329   if g:neocomplete#enable_insert_char_pre && neocomplete.skip_next_complete
  123   0.107066   0.000601     call neocomplete#handler#_do_auto_complete('InsertCharPre')
  123              0.000070   endif
                            
  135              0.000329   if getline('.') == ''
                                call s:make_cache_current_line()
                              endif
                            
                              " indent line matched by indentkeys
  135              0.001644   let cur_text = matchstr(getline('.'), '^.*\%'.col('.').'c')
  135              0.001325   if neocomplete.indent_text != matchstr(getline('.'), '\S.*$')
  128              0.007968     for word in filter(map(split(&l:indentkeys, ','), "v:val =~ '^<.*>$' ? matchstr(v:val, '^<\\zs.*\\ze>$')                  : matchstr(v:val, '.*=\\zs.*')"), "v:val != ''")
                                  if stridx(cur_text, word, len(cur_text)-len(word)-1) >= 0
                                    call neocomplete#helper#indent_current_line()
                                    let neocomplete.indent_text = matchstr(getline('.'), '\S.*$')
                                    break
                                  endif
                                endfor
  128              0.000081   endif

FUNCTION  airline#parts#paste()
Called 271 times
Total time:   0.000939
 Self time:   0.000939

count  total (s)   self (s)
  271              0.000789   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>179_check_changed_buffer()
Called 20 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
   20              0.000066   let source = s:buffer_sources[a:bufnr]
                            
   20              0.000074   let ft = getbufvar(a:bufnr, '&filetype')
   20              0.000030   if ft == ''
                                let ft = 'nothing'
                              endif
                            
   20              0.000076   let filename = fnamemodify(bufname(a:bufnr), ':t')
   20              0.000025   if filename == ''
                                let filename = '[No Name]'
                              endif
                            
   20              0.000064   return source.name != filename || source.filetype != ft

FUNCTION  unite#sources#rec#_append()
Called 3 times
Total time:   0.000408
 Self time:   0.000393

count  total (s)   self (s)
    3              0.000092   let path = expand('%:p')
    3              0.000055   if path !~ '\a\+:'
    3              0.000063     let path = simplify(resolve(path))
    3              0.000002   endif
                            
                              " Append the current buffer to the mru list.
    3              0.000060   if !filereadable(path) || &l:buftype =~# 'help\|nofile'
                                return
                              endif
                            
    3   0.000036   0.000026   let path = unite#util#substitute_path_separator(path)
                            
                              " Check continuation.
    3   0.000025   0.000020   let base_path = unite#util#substitute_path_separator( fnamemodify(path, ':h')) . '/'
    3              0.000037   for continuation in values(filter(copy(s:continuation.file), "stridx(v:key.'/', base_path) == 0"))
                                let continuation.files = unite#util#uniq(add( continuation.files, { 'word' : path, 'action__path' : path, }))
                              endfor

FUNCTION  airline#update_statusline()
Called 1 time
Total time:   0.011237
 Self time:   0.000159

count  total (s)   self (s)
    2              0.000017   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    1   0.000019   0.000012     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    1              0.000008     call setwinvar(nr, 'airline_active', 0)
    1              0.000008     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    1   0.004107   0.000021     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    1              0.000001   endfor
                            
    1              0.000002   unlet! w:airline_render_left
    1              0.000001   unlet! w:airline_render_right
    9              0.000009   for section in s:sections
    8              0.000016     unlet! w:airline_section_{section}
    8              0.000004   endfor
                            
    1              0.000001   let w:airline_active = 1
    1              0.000005   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    1   0.007012   0.000027   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  neocomplete#init#is_enabled()
Called 590 times
Total time:   0.001410
 Self time:   0.001410

count  total (s)   self (s)
  590              0.001021   return s:is_enabled

FUNCTION  <SNR>97_init()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:airline_theme_defined = exists('g:airline_theme')
                              if s:airline_theme_defined || !airline#switch_matching_theme()
                                let g:airline_theme = get(g:, 'airline_theme', 'dark')
                                call airline#switch_theme(g:airline_theme)
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 3 times
Total time:   0.001382
 Self time:   0.001376

count  total (s)   self (s)
    3   0.000020   0.000014   let bufnr = gitgutter#utility#bufnr()
    3              0.000005   let signs_to_remove = []  " list of [<id (number)>, ...]
    3              0.000004   let remove_all_signs = 1
    3              0.000011   let old_gitgutter_signs = getbufvar(bufnr, 'gitgutter_gitgutter_signs')
  133              0.000210   for line_number in keys(old_gitgutter_signs)
  130              0.000425     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
  130              0.000179       let remove_all_signs = 0
  130              0.000078     endif
  130              0.000061   endfor
    3              0.000012   let s:remove_all_old_signs = remove_all_signs
    3              0.000005   return signs_to_remove

FUNCTION  gitgutter#diff#is_removed()
Called 12 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
   12              0.000024   return a:from_count > 0 && a:to_count == 0

FUNCTION  airline#parts#readonly()
Called 298 times
Total time:   0.000906
 Self time:   0.000906

count  total (s)   self (s)
  298              0.000694   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  <SNR>130_get_array()
Called 1256 times
Total time:   0.017046
 Self time:   0.017046

count  total (s)   self (s)
 1256              0.002066   let fg = a:fg
 1256              0.001754   let bg = a:bg
 1256              0.012226   return has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  <SNR>97_on_window_changed()
Called 1 time
Total time:   0.011289
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000006   if pumvisible()
                                return
                              endif
    1   0.000022   0.000015   call s:init()
    1   0.011255   0.000018   call airline#update_statusline()

FUNCTION  neocomplete#is_multibyte_input()
Called 262 times
Total time:   0.011032
 Self time:   0.011032

count  total (s)   self (s)
  262              0.010882   return (exists('b:skk_on') && b:skk_on)   || (!g:neocomplete#enable_multibyte_completion         && char2nr(split(a:cur_text, '\zs')[-1]) > 0x80)

FUNCTION  <SNR>135_build_sections()
Called 3 times
Total time:   0.001217
 Self time:   0.000290

count  total (s)   self (s)
   14              0.000044   for key in a:keys
   11              0.000034     if key == 'warning' && !a:context.active
    1              0.000002       continue
                                endif
   10   0.001058   0.000131     call s:add_section(a:builder, a:context, key)
   10              0.000015   endfor

FUNCTION  <SNR>121_sync_active_winnr()
Called 52 times
Total time:   0.000505
 Self time:   0.000505

count  total (s)   self (s)
   52              0.000305   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#highlighter#exec()
Called 3195 times
Total time:   0.108353
 Self time:   0.108353

count  total (s)   self (s)
 3195              0.005576   let colors = a:colors
 3195              0.003177   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 3195              0.075325   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  neocomplete#mappings#cancel_popup()
Called 15 times
Total time:   0.000266
 Self time:   0.000163

count  total (s)   self (s)
   15   0.000169   0.000066   let neocomplete = neocomplete#get_current_neocomplete()
   15              0.000023   let neocomplete.skip_next_complete = 1
                            
   15              0.000041   return pumvisible() ? "\<C-e>" : ''

FUNCTION  <SNR>86__translateFilter()
Called 3 times
Total time:   0.000348
 Self time:   0.000183

count  total (s)   self (s)
    3              0.000008     let conditions = []
    6              0.000017     for k in keys(a:filters)
    3              0.000015         if type(a:filters[k]) == type([])
                                        call extend(conditions, map(copy(a:filters[k]), 's:_translateElement(k, v:val)'))
                                    else
    3   0.000209   0.000044             call add(conditions, s:_translateElement(k, a:filters[k]))
    3              0.000003         endif
    3              0.000019     endfor
                            
    3              0.000006     if conditions == []
                                    let conditions = ['1']
                                endif
    3              0.000012     return len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')

FUNCTION  airline#extensions#whitespace#check()
Called 271 times
Total time:   0.013294
 Self time:   0.011264

count  total (s)   self (s)
  271              0.001194   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
  271              0.000833   if !exists('b:airline_whitespace_check')
    5              0.000018     let b:airline_whitespace_check = ''
    5              0.000025     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    5              0.000009     let trailing = 0
    5              0.000016     if index(checks, 'trailing') > -1
    5              0.001064       let trailing = search('\s$', 'nw')
    5              0.000007     endif
                            
    5              0.000010     let mixed = 0
    5              0.000013     if index(checks, 'indent') > -1
    5   0.002073   0.000043       let mixed = s:check_mixed_indent()
    5              0.000006     endif
                            
    5              0.000009     if trailing != 0 || mixed != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                  endif
                                endif
    5              0.000003   endif
  271              0.000377   return b:airline_whitespace_check

FUNCTION  <SNR>197_is_skip_auto_complete()
Called 279 times
Total time:   0.024411
 Self time:   0.018498

count  total (s)   self (s)
  279   0.003098   0.001214   let neocomplete = neocomplete#get_current_neocomplete()
                            
  279              0.003233   if (a:cur_text == neocomplete.old_cur_text     && line('.') == neocomplete.old_linenr) || (g:neocomplete#lock_iminsert && &l:iminsert) || (&l:formatoptions =~# '[tca]' && &l:textwidth > 0     && strwidth(a:cur_text) >= &l:textwidth)
                                let neocomplete.skip_next_complete = 0
                                return 1
                              endif
                            
  279              0.000386   if !neocomplete.skip_next_complete
   13              0.000014     return 0
                              endif
                            
                              " Check delimiter pattern.
  266              0.000389   let is_delimiter = 0
  266   0.005339   0.001310   let filetype = neocomplete#get_context_filetype()
                            
  784              0.002414   for delimiter in ['/', '.'] + get(g:neocomplete#delimiter_patterns, filetype, [])
  528              0.002820     if stridx(a:cur_text, delimiter, len(a:cur_text) - len(delimiter)) >= 0
   10              0.000016       let is_delimiter = 1
   10              0.000010       break
                                endif
  518              0.000389   endfor
                            
  266              0.000481   if is_delimiter && neocomplete.skip_next_complete == 2
    1              0.000001     let neocomplete.skip_next_complete = 0
    1              0.000001   endif
                            
  266              0.000163   return 0

FUNCTION  gitgutter#hunk#hunks()
Called 3 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    3              0.000005   return s:hunks

FUNCTION  293()
Called 3 times
Total time:   0.000142
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000031     let fts = split(a:filetype, '\m\.')
                            
    3   0.000029   0.000017     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    3   0.000065   0.000014         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  neocomplete#get_source_filetypes()
Called 302 times
Total time:   0.023851
 Self time:   0.001691

count  total (s)   self (s)
  302   0.023708   0.001548   return neocomplete#helper#get_source_filetypes(a:filetype)

FUNCTION  neocomplete#mappings#smart_close_popup()
Called 15 times
Total time:   0.000819
 Self time:   0.000320

count  total (s)   self (s)
                              " Don't skip next complete.
   15   0.000362   0.000129   let neocomplete = neocomplete#get_current_neocomplete()
   15              0.000042   let neocomplete.skip_next_complete = 0
   15              0.000023   let neocomplete.old_linenr = 0
                            
   15   0.000329   0.000063   return neocomplete#mappings#cancel_popup()

FUNCTION  295()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000009     return self._mode ==# 'passive'

FUNCTION  <SNR>160_garbage_collect()
Called 5 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    5              0.000021   for pid in values(s:bg_processes)
                                " Check processes.
                                try
                                  let [cond, _] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, _])
                                  if cond !=# 'run' || a:is_force
                                    if cond !=# 'exit'
                                      " Kill process.
                                      call vimproc#kill(pid, g:vimproc#SIGTERM)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
                                endtry
                              endfor

FUNCTION  <SNR>85__os_name()
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000012     return g:_SYNTASTIC_UNAME

FUNCTION  neocomplete#handler#_do_auto_complete()
Called 279 times
Total time:   0.252530
 Self time:   0.023701

count  total (s)   self (s)
  279   0.017471   0.001172   if s:check_in_do_auto_complete()
                                return
                              endif
                            
  279   0.002942   0.001189   let neocomplete = neocomplete#get_current_neocomplete()
  279              0.000480   let neocomplete.skipped = 0
  279              0.000550   let neocomplete.event = a:event
                            
  279   0.027814   0.001289   let cur_text = neocomplete#get_cur_text(1)
                            
  279   0.002820   0.001435   call neocomplete#print_debug('cur_text = ' . cur_text)
                            
                              " Prevent infinity loop.
  279   0.025765   0.001354   if s:is_skip_auto_complete(cur_text)
                                call neocomplete#print_debug('Skipped.')
                                return
                              endif
                            
  279   0.015724   0.001516   let complete_pos = neocomplete#helper#get_force_omni_complete_pos(cur_text)
  279              0.000338   if complete_pos >= 0
                                if !s:check_previous_position(cur_text, complete_pos)
                                  call s:set_previous_position(cur_text, complete_pos)
                                  call s:complete_key("\<Plug>(neocomplete_start_omni_complete)")
                                endif
                            
                                return
                              endif
                            
                              " Check multibyte input or eskk or spaces.
  279   0.015166   0.003101   if cur_text =~ '^\s*$' || neocomplete#is_eskk_enabled() || neocomplete#is_multibyte_input(cur_text)
   17   0.000181   0.000096     call neocomplete#print_debug('Skipped.')
   17              0.000012     return
                              endif
                            
                              " Check complete position.
  262   0.133896   0.002866   let complete_sources = neocomplete#complete#_set_results_pos(cur_text)
  262              0.000519   if empty(complete_sources)
  262   0.002206   0.001138     call neocomplete#print_debug('Skipped.')
  262              0.000186     return
                              endif
                            
                              " Check previous position
                              let complete_pos = neocomplete#complete#_get_complete_pos(complete_sources)
                              if s:check_previous_position(cur_text, complete_pos)
                                " Same position.
                                return
                              endif
                            
                              call s:set_previous_position(cur_text, complete_pos)
                            
                              try
                                let neocomplete.is_auto_complete = 1
                            
                                " Do prefetch.
                                let neocomplete.complete_sources = neocomplete#complete#_get_results(cur_text)
                              finally
                                let neocomplete.is_auto_complete = 0
                              endtry
                            
                              if empty(neocomplete.complete_sources)
                                if !empty(g:neocomplete#fallback_mappings) && len(matchstr(cur_text, '\h\w*$'))   >= g:neocomplete#auto_completion_start_length
                                  let key = ''
                                  for i in range(0, len(g:neocomplete#fallback_mappings)-1)
                                    let key .= '<C-r>=neocomplete#mappings#fallback(' . i . ')<CR>'
                                  endfor
                                  execute 'inoremap <silent> <Plug>(neocomplete_fallback)' key
                            
                                  " Fallback to omnifunc
                                  call s:complete_key("\<Plug>(neocomplete_fallback)")
                                else
                                  call neocomplete#print_debug('Skipped.')
                                  return
                                endif
                                return
                              endif
                            
                              let complete_pos = neocomplete#complete#_get_complete_pos( neocomplete.complete_sources)
                              let base = cur_text[complete_pos :]
                            
                              let neocomplete.candidates = neocomplete#complete#_get_words( neocomplete.complete_sources, complete_pos, base)
                            
                              " Start auto complete.
                              call s:complete_key( "\<Plug>(neocomplete_start_auto_complete)")

FUNCTION  gitgutter#utility#not_git_dir()
Called 5 times
Total time:   0.000227
 Self time:   0.000085

count  total (s)   self (s)
    5   0.000224   0.000082   return gitgutter#utility#full_path_to_directory_of_file() !~ '\.git\([/\\].*\)\?$'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 5 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    5              0.000138   return fnamemodify(s:file, ':p:h')

FUNCTION  neocomplete#helper#get_source_filetypes()
Called 302 times
Total time:   0.022160
 Self time:   0.017267

count  total (s)   self (s)
  302              0.001076   let filetype = (a:filetype == '') ? 'nothing' : a:filetype
                            
  302              0.000654   let filetypes = [filetype]
  302              0.001122   if filetype =~ '\.'
                                if exists('g:neocomplete#ignore_composite_filetypes') && has_key(g:neocomplete#ignore_composite_filetypes, filetype)
                                  let filetypes = [g:neocomplete#ignore_composite_filetypes[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
                              endif
                            
  302              0.000818   if exists('g:neocomplete#same_filetypes')
  604              0.001369     for ft in copy(filetypes)
  302              0.002615       let filetypes += split(get(g:neocomplete#same_filetypes, ft, get(g:neocomplete#same_filetypes, '_', '')), ',')
  302              0.000302     endfor
  302              0.000189   endif
  302   0.006064   0.001171   if neocomplete#is_text_mode()
                                call add(filetypes, 'text')
                              endif
                            
  302              0.000546   if len(filetypes) > 1
                                let filetypes = neocomplete#util#uniq(filetypes)
                              endif
                            
  302              0.000257   return filetypes

FUNCTION  neocomplete#helper#get_cur_text()
Called 279 times
Total time:   0.021529
 Self time:   0.019719

count  total (s)   self (s)
  279   0.002870   0.001060   let neocomplete = neocomplete#get_current_neocomplete()
  279              0.000871   let is_skip_char = get(a:000, 0, 0)
                            
  279              0.004940   let cur_text = (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode() ==# 'i' && !is_skip_char ?                    col('.') : col('.') - 1)         . 'c' . (mode() ==# 'i' ? '' : '.'))
                            
  279              0.003110   if cur_text =~ '^.\{-}\ze\S\+$'
  238              0.002141     let complete_str = matchstr(cur_text, '\S\+$')
  238              0.002268     let cur_text = matchstr(cur_text, '^.\{-}\ze\S\+$')
  238              0.000235   else
   41              0.000069     let complete_str = ''
   41              0.000029   endif
                            
  279              0.000546   if neocomplete.event ==# 'InsertCharPre'
  267              0.000733     let complete_str .= v:char
  267              0.000161   endif
                            
  279              0.000882   let neocomplete.cur_text = cur_text . complete_str
                            
                              " Save cur_text.
  279              0.000377   return neocomplete.cur_text

FUNCTION  <SNR>139_ProcessFile()
Called 3 times
Total time:   0.085464
 Self time:   0.010611

count  total (s)   self (s)
    3   0.000037   0.000019     call s:debug('ProcessFile called [' . a:fname . ']')
                            
    3   0.000251   0.000012     if !s:IsValidFile(a:fname, a:ftype)
                                    call s:debug('Not a valid file, returning')
                                    return
                                endif
                            
    3              0.000014     let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
    3   0.000056   0.000029     if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) && s:known_files.get(a:fname).ftype == a:ftype
    3   0.000018   0.000011         let fileinfo = s:known_files.get(a:fname)
    3              0.000004         let typeinfo = fileinfo.typeinfo
    3   0.000496   0.000016         call fileinfo.reset()
    3              0.000001     else
                                    if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
                                    endif
                                    let fileinfo = s:FileInfo.New(a:fname, a:ftype, typeinfo)
                                endif
                            
    3   0.000207   0.000185     call s:debug('typeinfo for file to process: ' . string(typeinfo))
                            
                                " Use a temporary files for ctags processing instead of the original one.
                                " This allows using Tagbar for files accessed with netrw, and also doesn't
                                " slow down Tagbar for files that sit on slow network drives.
    3              0.000010     let tempfile = tempname()
    3              0.000011     let ext = fnamemodify(fileinfo.fpath, ':e')
    3              0.000005     if ext != ''
    3              0.000009         let tempfile .= '.' . ext
    3              0.000001     endif
                            
    3              0.006252     call writefile(getbufline(fileinfo.bufnr, 1, '$'), tempfile)
    3              0.000050     let fileinfo.mtime = getftime(tempfile)
                            
    3   0.050770   0.000241     let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
    3              0.000225     call delete(tempfile)
                            
    3              0.000018     if ctags_output == -1
                                    call s:debug('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
                                elseif ctags_output == ''
                                    call s:debug('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(s:FileInfo.New(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                    return
                                endif
                            
    3   0.000174   0.000151     call s:debug('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
    3   0.000026   0.000009     call s:debug('Parsing ctags output')
    3              0.000139     let rawtaglist = split(ctags_output, '\n\+')
   48              0.000084     for line in rawtaglist
                                    " skip comments
   45              0.000220         if line =~# '^!_TAG_'
                                        continue
                                    endif
                            
   45              0.000275         let parts = split(line, ';"')
   45              0.000086         if len(parts) == 2 " Is a valid tag line
   45   0.018166   0.000491             let taginfo = s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
   45              0.000085             if !empty(taginfo)
   45              0.000173                 let fileinfo.fline[taginfo.fields.line] = taginfo
   45              0.000117                 call add(fileinfo.tags, taginfo)
   45              0.000032             endif
   45              0.000013         endif
   45              0.000033     endfor
                            
                                " Process scoped tags
    3              0.000007     let processedtags = []
    3              0.000009     if has_key(typeinfo, 'kind2scope')
    3   0.000046   0.000016         call s:debug('Processing scoped tags')
                            
    3              0.000006         let scopedtags = []
    3              0.000008         let is_scoped = 'has_key(typeinfo.kind2scope, v:val.fields.kind) || has_key(v:val, "scope")'
    3              0.000241         let scopedtags += filter(copy(fileinfo.tags), is_scoped)
    3              0.000116         call filter(fileinfo.tags, '!(' . is_scoped . ')')
                            
    3   0.002411   0.000055         call s:AddScopedTags(scopedtags, processedtags, {}, 0, typeinfo, fileinfo, line('$'))
                            
    3              0.000004         if !empty(scopedtags)
                                        echoerr 'Tagbar: ''scopedtags'' not empty after processing,' 'this should never happen!' 'Please contact the script maintainer with an example.'
                                    endif
    3              0.000002     endif
    3   0.000045   0.000023     call s:debug('Number of top-level tags: ' . len(processedtags))
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes
   39              0.000037     for kind in typeinfo.kinds
                            
   36              0.000166         let curtags = filter(copy(fileinfo.tags), 'v:val.fields.kind ==# kind.short')
   36   0.000459   0.000236         call s:debug('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
   36              0.000048         if empty(curtags)
   36              0.000030             continue
                                    endif
                            
                                    let kindtag          = s:KindheaderTag.New(kind.long)
                                    let kindtag.short    = kind.short
                                    let kindtag.numtags  = len(curtags)
                                    let kindtag.fileinfo = fileinfo
                            
                                    for tag in curtags
                                        let tag.parent = kindtag
                                    endfor
                                endfor
                            
    3              0.000005     if !empty(processedtags)
    3              0.000006         call extend(fileinfo.tags, processedtags)
    3              0.000002     endif
                            
                                " Clear old folding information from previous file version to prevent leaks
    3   0.000186   0.000018     call fileinfo.clearOldFolds()
                            
                                " Sort the tags
    3              0.000009     let s:compare_typeinfo = typeinfo
    3   0.002992   0.000012     call fileinfo.sortTags()
                            
    3   0.000053   0.000016     call s:known_files.put(fileinfo)

FUNCTION  gitgutter#hunk#summary()
Called 270 times
Total time:   0.000582
 Self time:   0.000582

count  total (s)   self (s)
  270              0.000450   return s:summary

FUNCTION  <SNR>139_EscapeCtagsCmd()
Called 3 times
Total time:   0.000673
 Self time:   0.000579

count  total (s)   self (s)
    3   0.000053   0.000017     call s:debug('EscapeCtagsCmd called')
    3   0.000034   0.000015     call s:debug('ctags_bin: ' . a:ctags_bin)
    3              0.000007     if type(a:args)==type('')
                                    call s:debug('ctags_args (is a string): ' . a:args)
                                elseif type(a:args)==type([])
    3   0.000079   0.000060         call s:debug('ctags_args (is a list): ' . string(a:args))
    3              0.000002     endif
                            
    3              0.000009     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
    3              0.000026     if &shell =~ 'cmd\.exe$' && a:ctags_bin !~ '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
                                    let ctags_cmd = a:ctags_bin
                                else
    3              0.000012         let ctags_cmd = shellescape(a:ctags_bin)
    3              0.000001     endif
                            
                                "Add additional arguments to ctags_cmd
    3              0.000009     if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
                                    let ctags_cmd .= ' ' . a:args
                                elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
   33              0.000029         for arg in a:args
   30              0.000109             let ctags_cmd .= ' ' . shellescape(arg)
   30              0.000020         endfor
    3              0.000002     endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
    3              0.000003     if a:0 == 1
    3              0.000018         let ctags_cmd .= ' ' . shellescape(a:1)
    3              0.000000     endif
                            
    3              0.000006     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
    3              0.000010     if has('multi_byte')
    3              0.000008         if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
                                    elseif $LANG != ''
    3              0.000034             let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
    3              0.000001         endif
    3              0.000002     endif
                            
    3   0.000045   0.000025     call s:debug('Escaped ctags command: ' . ctags_cmd)
                            
    3              0.000005     if ctags_cmd == ''
                                    if !s:warnings.encoding
                                        call s:warning('Tagbar: Ctags command encoding conversion failed!' . ' Please read ":h g:tagbar_systemenc".')
                                        let s:warnings.encoding = 1
                                    endif
                                endif
                            
    3              0.000003     return ctags_cmd

FUNCTION  gitgutter#utility#shell_error()
Called 3 times
Total time:   0.000149
 Self time:   0.000051

count  total (s)   self (s)
    3   0.000134   0.000036   return gitgutter#utility#using_xolox_shell() ? s:exit_code : v:shell_error

FUNCTION  airline#extensions#tagbar#currenttag()
Called 297 times
Total time:   0.020443
 Self time:   0.004462

count  total (s)   self (s)
  297              0.000802   if get(w:, 'airline_active', 0)
  270              0.000898     if s:airline_tagbar_last_lookup_time != localtime()
   55   0.016427   0.000446       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   55              0.000164       let s:airline_tagbar_last_lookup_time = localtime()
   55              0.000030     endif
  270              0.000454     return s:airline_tagbar_last_lookup_val
                              endif
   27              0.000011   return ''

FUNCTION  gitgutter#utility#bufnr()
Called 15 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
   15              0.000026   return s:bufnr

FUNCTION  <SNR>139_ParseTagline()
Called 45 times
Total time:   0.017675
 Self time:   0.014248

count  total (s)   self (s)
   45              0.000278     let basic_info  = split(a:part1, '\t')
                            
   45   0.002310   0.000240     let taginfo      = s:NormalTag.New(basic_info[0])
   45              0.000122     let taginfo.file = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
   45              0.000210     let pattern = join(basic_info[2:], "\t")
   45              0.000067     let start   = 2 " skip the slash and the ^
   45              0.000141     let end     = strlen(pattern) - 1
   45              0.000113     if pattern[end - 1] ==# '$'
   45              0.000063         let end -= 1
   45              0.000071         let dollar = '\$'
   45              0.000031     else
                                    let dollar = ''
                                endif
   45              0.000172     let pattern         = strpart(pattern, start, end - start)
   45              0.000156     let taginfo.pattern = '\V\^\C' . pattern . dollar
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
   45              0.000705     let fields = split(a:part2, '^\t\|\t\ze\w\+:')
   45              0.000312     if fields[0] !~# ':'
   45              0.000144         let taginfo.fields.kind = remove(fields, 0)
   45              0.000022     endif
  207              0.000275     for field in fields
                                    " can't use split() since the value can contain ':'
  162              0.000435         let delimit = stridx(field, ':')
  162              0.000416         let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
  162              0.001088         let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                    " File-restricted scoping
  162              0.000258         if key == "file"
   15              0.000031             let taginfo.fields[key] = 'yes'
   15              0.000010         endif
  162              0.000316         if len(val) > 0
  147              0.000293             if key == 'line' || key == 'column'
   45              0.000155                 let taginfo.fields[key] = str2nr(val)
   45              0.000042             else
  102              0.000214                 let taginfo.fields[key] = val
  102              0.000096             endif
  147              0.000074         endif
  162              0.000111     endfor
                                " Needed for jsctags
   45              0.000111     if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
                                endif
                                " Do some sanity checking in case ctags reports invalid line numbers
   45              0.000072     if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
                                endif
                            
   45              0.000091     if !has_key(taginfo.fields, 'kind')
                                    call s:debug("Warning: No 'kind' field found for tag " . basic_info[0] . "!")
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning("No 'kind' field found for tag " . basic_info[0] . "!" . " Please read the last section of ':help tagbar-extend'.")
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return {}
                                endif
                            
                                " Make some information easier accessible
   45              0.000098     if has_key(a:typeinfo, 'scope2kind')
  186              0.000461         for scope in keys(a:typeinfo.scope2kind)
  183              0.000533             if has_key(taginfo.fields, scope)
   42              0.000083                 let taginfo.scope = scope
   42              0.000102                 let taginfo.path  = taginfo.fields[scope]
                            
   42              0.000195                 let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
   42              0.000038                 break
                                        endif
  141              0.000125         endfor
   45              0.000319         let taginfo.depth = len(split(taginfo.path, '\V' . a:typeinfo.sro))
   45              0.000027     endif
                            
   45              0.000077     let taginfo.fileinfo = a:fileinfo
   45              0.000067     let taginfo.typeinfo = a:typeinfo
                            
                                " Needed for folding
   45              0.000032     try
   45   0.001531   0.000174         call taginfo.initFoldState()
   45              0.000046     catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call s:debug('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning('Unknown tag kind encountered: ' . '"' . taginfo.fields.kind . '".' . ' Your ctags and Tagbar configurations are out of sync!' . ' Please read '':help tagbar-extend''.')
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return {}
                                endtry
                            
   45              0.000042     return taginfo

FUNCTION  gitgutter#diff#run_diff()
Called 3 times
Total time:   0.041404
 Self time:   0.000447

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
    3              0.000006   let cmd = '('
                            
    3   0.000020   0.000014   let bufnr = gitgutter#utility#bufnr()
    3              0.000011   let tracked = getbufvar(bufnr, 'gitgutter_tracked')  " i.e. tracked by git
    3              0.000003   if !tracked
                                let cmd .= 'git ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
                              endif
                            
    3              0.000003   if a:realtime
                                let blob_name = ':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = tempname()
                                let buff_file = tempname()
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= 'git show '.blob_name.' > '.blob_file.' && '
                                execute 'keepalt silent write' buff_file
                              endif
                            
    3              0.000013   let cmd .= 'git diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '
    3              0.000003   if a:realtime
                                let cmd .= blob_file.' '.buff_file
                              else
    3   0.000075   0.000026     let cmd .= gitgutter#utility#shellescape(gitgutter#utility#filename())
    3              0.000002   endif
                            
    3              0.000006   if a:use_external_grep && s:grep_available
    3              0.000007     let cmd .= s:grep_command
    3              0.000001   endif
                            
    3              0.000006   if (a:use_external_grep && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    3              0.000006     let cmd.= ' || exit 0'
    3              0.000002   endif
                            
    3              0.000005   let cmd .= ')'
                            
    3              0.000003   if !tracked
                                let cmd .= ')'
                              endif
                            
    3   0.040852   0.000099   let diff = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(cmd))
                            
    3              0.000006   if a:realtime
                                call delete(blob_file)
                                call delete(buff_file)
                              endif
                            
    3   0.000199   0.000050   if gitgutter#utility#shell_error()
                                " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                throw 'diff failed'
                              endif
                            
    3              0.000003   if !tracked
                                call setbufvar(bufnr, 'gitgutter_tracked', 1)
                              endif
                            
    3              0.000006   return diff

FUNCTION  GitGutterGetHunkSummary()
Called 270 times
Total time:   0.001613
 Self time:   0.001031

count  total (s)   self (s)
  270   0.001469   0.000887   return gitgutter#hunk#summary()

FUNCTION  airline#parts#mode()
Called 271 times
Total time:   0.001173
 Self time:   0.001173

count  total (s)   self (s)
  271              0.000963   return get(w:, 'airline_current_mode', '')

FUNCTION  UltiSnips#LeavingInsertMode()
Called 12 times
Total time:   0.001085
 Self time:   0.001085

count  total (s)   self (s)
   12              0.001056     exec g:_uspy "UltiSnips_Manager._leaving_insert_mode()"

FUNCTION  <SNR>179_exists_current_source()
Called 20 times
Total time:   0.000640
 Self time:   0.000182

count  total (s)   self (s)
   20   0.000618   0.000160   return has_key(s:buffer_sources, bufnr('%')) && !s:check_changed_buffer(bufnr('%'))

FUNCTION  gitgutter#diff#process_modified()
Called 3 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    3              0.000006   let offset = 0
    6              0.000011   while offset < a:to_count
    3              0.000010     let line_number = a:to_line + offset
    3              0.000014     call add(a:modifications, [line_number, 'modified'])
    3              0.000005     let offset += 1
    3              0.000003   endwhile

FUNCTION  airline#extensions#quickfix#apply()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000015   let s:summary[2] += a:count

FUNCTION  <SNR>191_set_complete_results_pos()
Called 262 times
Total time:   0.010977
 Self time:   0.010977

count  total (s)   self (s)
                              " Try omnifunc completion. "{{{
  262              0.000560   let complete_results = {}
  262              0.000507   for [omnifunc, pattern] in a:funcs
                                if neocomplete#is_auto_complete() && a:cur_text !~# '\%(' . pattern . '\m\)$'
                                  continue
                                endif
                            
                                " Save pos.
                                let pos = getpos('.')
                            
                                try
                                  let complete_pos = call(omnifunc, [1, ''])
                                catch
                                  call neocomplete#print_error( 'Error occurred calling omnifunction: ' . omnifunc)
                                  call neocomplete#print_error(v:throwpoint)
                                  call neocomplete#print_error(v:exception)
                                  let complete_pos = -1
                                finally
                                  if getpos('.') != pos
                                    call setpos('.', pos)
                                  endif
                                endtry
                            
                                if complete_pos < 0
                                  continue
                                endif
                            
                                let complete_str = a:cur_text[complete_pos :]
                            
                                let complete_results[omnifunc] = { 'candidates' : [], 'complete_pos' : complete_pos, 'complete_str' : complete_str, 'omnifunc' : omnifunc,}
                              endfor
                              "}}}
                            
  262              0.000352   return complete_results

FUNCTION  <SNR>137_save()
Called 9 times
Total time:   0.005845
 Self time:   0.005788

count  total (s)   self (s)
    9   0.000109   0.000052   if g:unite_source_history_yank_file == '' || unite#util#is_sudo()
                                return
                              endif
                            
    9              0.005580   call writefile([string(s:yank_histories)],              g:unite_source_history_yank_file)
    9              0.000118   let s:yank_histories_file_mtime = getftime(g:unite_source_history_yank_file)

FUNCTION  230()
Called 3 times
Total time:   0.000161
 Self time:   0.000030

count  total (s)   self (s)
    3   0.000037   0.000013     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    3   0.000119   0.000012     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  231()
Called 3 times
Total time:   0.000107
 Self time:   0.000061

count  total (s)   self (s)
    3   0.000034   0.000015     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    3   0.000015   0.000009     if !a:loclist.isEmpty()
                                    if syntastic#util#var('auto_loc_list') == 1
                                        call a:loclist.show()
                                    endif
                                else
    3   0.000030   0.000009         if syntastic#util#var('auto_loc_list') > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    3              0.000004             lclose
    3              0.000001         endif
    3              0.000001     endif

FUNCTION  233()
Called 6 times
Total time:   0.000078
 Self time:   0.000033

count  total (s)   self (s)
    6   0.000069   0.000024     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  234()
Called 3 times
Total time:   0.000087
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000006     unlet! b:syntastic_private_balloons
    3   0.000055   0.000013     if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  235()
Called 3 times
Total time:   0.000097
 Self time:   0.000068

count  total (s)   self (s)
    3              0.000019     let b:syntastic_private_balloons = {}
    3              0.000007     if has('balloon_eval')
    3   0.000042   0.000013         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
    3              0.000006         unlet! b:syntastic_private_balloons
    3              0.000012         set noballooneval
    3              0.000001     endif

FUNCTION  237()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000006     return self._filetype

FUNCTION  238()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000007     return self._name

FUNCTION  239()
Called 3 times
Total time:   0.000098
 Self time:   0.000078

count  total (s)   self (s)
    3   0.000061   0.000041     let user_exec = expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec : syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
    3              0.000006     if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif

FUNCTION  <SNR>139_CompareByKind()
Called 138 times
Total time:   0.002287
 Self time:   0.002287

count  total (s)   self (s)
  138              0.000237     let typeinfo = s:compare_typeinfo
                            
  138              0.000327     if typeinfo.kinddict[a:tag1.fields.kind] <# typeinfo.kinddict[a:tag2.fields.kind]
   24              0.000021         return -1
                                elseif typeinfo.kinddict[a:tag1.fields.kind] ># typeinfo.kinddict[a:tag2.fields.kind]
   42              0.000030         return 1
                                else
                                    " Ignore '~' prefix for C++ destructors to sort them directly under
                                    " the constructors
   72              0.000148         if a:tag1.name[0] ==# '~'
                                        let name1 = a:tag1.name[1:]
                                    else
   72              0.000095             let name1 = a:tag1.name
   72              0.000045         endif
   72              0.000128         if a:tag2.name[0] ==# '~'
                                        let name2 = a:tag2.name[1:]
                                    else
   72              0.000105             let name2 = a:tag2.name
   72              0.000034         endif
                            
   72              0.000087         if name1 <=# name2
   33              0.000023             return -1
                                    else
   39              0.000022             return 1
                                    endif
                                endif

FUNCTION  241()
Called 3 times
Total time:   0.000078
 Self time:   0.000033

count  total (s)   self (s)
    3   0.000074   0.000029     return syntastic#util#shescape(self._exec)

FUNCTION  242()
Called 3 times
Total time:   0.485193
 Self time:   0.000232

count  total (s)   self (s)
    3              0.000014     let name = self._filetype . '/' . self._name
    3              0.000004     try
    3   0.484241   0.000060         let list = self._locListFunc()
    3              0.000009         if self._exec !=# ''
    3   0.000052   0.000028             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    3              0.000001         endif
    3              0.000003     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
    3   0.000063   0.000020     call self._populateHighlightRegexes(list)
    3   0.000035   0.000016     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    3   0.000715   0.000021     call self._quietMessages(list)
    3              0.000009     return list

FUNCTION  243()
Called 3 times
Total time:   0.485473
 Self time:   0.000072

count  total (s)   self (s)
    3   0.485466   0.000065     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  247()
Called 3 times
Total time:   0.001349
 Self time:   0.000168

count  total (s)   self (s)
    3              0.000014     let basename = self._filetype . '_' . self._name . '_'
                            
    3              0.000006     let parts = []
    3   0.000433   0.000045     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    3   0.000233   0.000025     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    3   0.000275   0.000029     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    3   0.000187   0.000015     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    3   0.000183   0.000016     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    3              0.000008     return join(parts)

FUNCTION  248()
Called 3 times
Total time:   0.000138
 Self time:   0.000040

count  total (s)   self (s)
    3   0.000113   0.000015     call self.syncExec()
    3              0.000007     if !has_key(self, '_available')
                                    let self._available = self._isAvailableFunc()
                                endif
    3              0.000003     return self._available

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000024   return getbufvar(s:bufnr, "&mod")

FUNCTION  455()
Called 262 times
Total time:   0.062621
 Self time:   0.006137

count  total (s)   self (s)
  262   0.004608   0.001176   let filetype = neocomplete#get_context_filetype()
  262   0.055221   0.003289   let a:context.source__complete_results = s:set_complete_results_pos(   s:get_omni_funcs(filetype), a:context.input)
                            
  262   0.002301   0.001181   return s:get_complete_pos(a:context.source__complete_results)

FUNCTION  delimitMate#JumpOut()
Called 1 time
Total time:   0.000220
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000114   0.000007   if s:is_forbidden(a:char)
                                return a:char
                              endif
    1   0.000099   0.000017   let jump = s:is_jump(a:char)
    1              0.000001   if jump == 1
                                " HACK: Instead of <Right>, we remove the char to be jumped over and
                                " insert it again. This will trigger re-indenting via 'indentkeys'.
                                " Ref: https://github.com/Raimondi/delimitMate/issues/168
    1              0.000002     return "\<Del>".a:char
                              elseif jump == 3
                                return "\<Right>\<Right>"
                              elseif jump == 5
                                return "\<Down>\<C-O>I\<Right>"
                              else
                                return a:char
                              endif

FUNCTION  <SNR>105_Highlight_Matching_Pair()
Called 337 times
Total time:   0.053743
 Self time:   0.053743

count  total (s)   self (s)
                              " Remove any previous match.
  337              0.001346   if exists('w:paren_hl_on') && w:paren_hl_on
  146              0.000404     3match none
  146              0.000314     let w:paren_hl_on = 0
  146              0.000105   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  337              0.001240   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  337              0.000926   let c_lnum = line('.')
  337              0.000760   let c_col = col('.')
  337              0.000427   let before = 0
                            
  337              0.001441   let c = getline(c_lnum)[c_col - 1]
  337              0.004576   let plist = split(&matchpairs, '.\zs[:,]')
  337              0.001074   let i = index(plist, c)
  337              0.000431   if i < 0
                                " not found, in Insert mode try character before the cursor
  192              0.000636     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  137              0.000172       let before = 1
  137              0.000521       let c = getline(c_lnum)[c_col - 2]
  137              0.000336       let i = index(plist, c)
  137              0.000096     endif
  192              0.000161     if i < 0
                                  " not found, nothing to do
  191              0.000169       return
                                endif
    1              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
  146              0.000167   if i % 2 == 0
   20              0.000032     let s_flags = 'nW'
   20              0.000074     let c2 = plist[i + 1]
   20              0.000020   else
  126              0.000175     let s_flags = 'nbW'
  126              0.000194     let c2 = c
  126              0.000382     let c = plist[i - 1]
  126              0.000088   endif
  146              0.000260   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  146              0.000137   if before > 0
    1              0.000004     let save_cursor = winsaveview()
    1              0.000003     call cursor(c_lnum, c_col - before)
    1              0.000001   endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
  146              0.000509   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
  146              0.005536   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
  146              0.000482   let stoplinebottom = line('w$')
  146              0.000374   let stoplinetop = line('w0')
  146              0.000179   if i % 2 == 0
   20              0.000054     let stopline = stoplinebottom
   20              0.000018   else
  126              0.000202     let stopline = stoplinetop
  126              0.000069   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  146              0.000383   if mode() == 'i' || mode() == 'R'
  135              0.000655     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  135              0.000075   else
   11              0.000053     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   11              0.000009   endif
  146              0.000120   try
  146              0.008342     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
  146              0.000238   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
  146              0.000174   if before > 0
    1              0.000053     call winrestview(save_cursor)
    1              0.000000   endif
                            
                              " If a match is found setup match highlighting.
  146              0.000354   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  146              0.003927     exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
  146              0.000331     let w:paren_hl_on = 1
  146              0.000084   endif

FUNCTION  SyntasticMake()
Called 3 times
Total time:   0.482681
 Self time:   0.001621

count  total (s)   self (s)
    3   0.000047   0.000023     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    3              0.000008     let old_local_errorformat = &l:errorformat
    3              0.000013     let old_errorformat = &errorformat
    3              0.000052     let old_cwd = getcwd()
                                " }}}3
                            
    3              0.000008     if has_key(a:options, 'errorformat')
    3              0.000028         let &errorformat = a:options['errorformat']
    3              0.000003     endif
                            
    3              0.000005     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    3              0.000007     let env_save = {}
    3              0.000006     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_]\+$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
    3   0.481105   0.000369     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    3              0.000018     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    3   0.000130   0.000060     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    3   0.000082   0.000032     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    3              0.000004     if !bailout
    3              0.000006         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
    3              0.000321         lgetexpr err_lines
                            
    3              0.000108         let errors = deepcopy(getloclist(0))
                            
    3              0.000007         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
    3              0.000003         try
    3              0.000032             silent lolder
    3              0.000005         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
    3              0.000003     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
    3              0.000033     let &errorformat = old_errorformat
    3              0.000006     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    3   0.000082   0.000063     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    3              0.000002     if bailout
                                    throw 'Syntastic: checker error'
                                endif
                            
    3   0.000054   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    3              0.000007     if has_key(a:options, 'defaults')
    3   0.000147   0.000026         call s:_add_to_errors(errors, a:options['defaults'])
    3              0.000000     endif
                            
                                " Add subtype info if present.
    3              0.000007     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    3              0.000008     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
    3              0.000006     return errors

FUNCTION  251()
Called 3 times
Total time:   0.000694
 Self time:   0.000175

count  total (s)   self (s)
                                " wildcard quiet_messages
    3   0.000057   0.000023     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    3              0.000013     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    3              0.000010     let name = self._filetype . '_' . self._name
    3              0.000001     try
    3   0.000050   0.000027         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    3              0.000003     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    3   0.000033   0.000013     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    3              0.000005     if !empty(quiet_filters)
    3   0.000441   0.000020         call syntastic#util#dictFilter(a:errors, quiet_filters)
    3   0.000036   0.000015         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
    3              0.000002     endif

FUNCTION  252()
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000010     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  253()
Called 15 times
Total time:   0.001034
 Self time:   0.000473

count  total (s)   self (s)
   15              0.000030     let ret = []
   15   0.000324   0.000132     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
   15   0.000413   0.000185     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
   15   0.000231   0.000090     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
   15              0.000012     return ret

FUNCTION  255()
Called 6 times
Total time:   0.000071
 Self time:   0.000027

count  total (s)   self (s)
    6   0.000063   0.000019     return syntastic#util#var('echo_current_error')

FUNCTION  256()
Called 3 times
Total time:   0.000083
 Self time:   0.000045

count  total (s)   self (s)
    3   0.000050   0.000012     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  257()
Called 3 times
Total time:   0.000065
 Self time:   0.000044

count  total (s)   self (s)
    3   0.000035   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    3              0.000014     autocmd! syntastic CursorMoved
    3              0.000004     unlet! b:syntastic_private_messages
    3              0.000009     let b:syntastic_private_line = -1

FUNCTION  259()
Called 6 times
Total time:   0.000078
 Self time:   0.000033

count  total (s)   self (s)
    6   0.000073   0.000028     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  gitgutter#hunk#reset()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000022   let s:summary = [0, 0, 0]

FUNCTION  gitgutter#utility#exists_file()
Called 5 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    5              0.000092   return filereadable(s:file)

FUNCTION  syntastic#util#unique()
Called 6 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
    6              0.000014     let seen = {}
    6              0.000011     let uniques = []
   12              0.000022     for e in a:list
    6              0.000017         if !has_key(seen, e)
    6              0.000024             let seen[e] = 1
    6              0.000015             call add(uniques, e)
    6              0.000002         endif
    6              0.000006     endfor
    6              0.000010     return uniques

FUNCTION  gitgutter#utility#directory_of_file()
Called 3 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    3              0.000010   return fnamemodify(s:file, ':h')

FUNCTION  airline#statusline()
Called 298 times
Total time:   0.005232
 Self time:   0.005232

count  total (s)   self (s)
  298              0.002135   if has_key(s:contexts, a:winnr)
  298              0.002391     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#utility#is_active()
Called 5 times
Total time:   0.000383
 Self time:   0.000059

count  total (s)   self (s)
    5   0.000380   0.000056   return g:gitgutter_enabled && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  260()
Called 3 times
Total time:   0.000265
 Self time:   0.000162

count  total (s)   self (s)
    3   0.000045   0.000012     if self.enabled()
    3   0.000033   0.000012         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    3   0.000044   0.000008         call self._reset()
    3              0.000008         let buf = bufnr('')
    3   0.000030   0.000017         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    3              0.000005         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    3              0.000002     endif

FUNCTION  261()
Called 3 times
Total time:   0.000110
 Self time:   0.000052

count  total (s)   self (s)
    3              0.000017     if s:has_highlighting
    3   0.000039   0.000017         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    3   0.000049   0.000013         call self._reset()
    3              0.000000     endif

FUNCTION  263()
Called 6 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000022     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  264()
Called 6 times
Total time:   0.000364
 Self time:   0.000364

count  total (s)   self (s)
    6              0.000169     let newObj = copy(self)
                            
    6              0.000034     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
    6              0.000021     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    6              0.000013     let newObj._rawLoclist = llist
    6              0.000008     let newObj._name = ''
    6              0.000016     let newObj._owner = bufnr('')
    6              0.000013     let newObj._sorted = 0
    6              0.000012     let newObj._columns = g:syntastic_cursor_columns
                            
    6              0.000006     return newObj

FUNCTION  265()
Called 277 times
Total time:   0.002651
 Self time:   0.002651

count  total (s)   self (s)
  277              0.001240     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
  277              0.000328     return b:syntastic_loclist

FUNCTION  268()
Called 18 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
   18              0.000039     return empty(self._rawLoclist)

FUNCTION  269()
Called 6 times
Total time:   0.000242
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000016     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    6   0.000204   0.000034     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    3              0.000027   call setbufvar(s:bufnr, 'gitgutter_last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  neocomplete#print_debug()
Called 558 times
Total time:   0.002538
 Self time:   0.002538

count  total (s)   self (s)
  558              0.000914   if g:neocomplete#enable_debug
                                echomsg string(a:expr)
                              endif

FUNCTION  neocomplete#handler#_on_insert_enter()
Called 12 times
Total time:   0.002160
 Self time:   0.000476

count  total (s)   self (s)
   12   0.000210   0.000078   if !neocomplete#is_enabled()
                                return
                              endif
                            
   12   0.000286   0.000090   let neocomplete = neocomplete#get_current_neocomplete()
   12              0.000055   if neocomplete.linenr != line('.')
    6   0.001387   0.000031     call neocomplete#helper#clear_result()
    6              0.000003   endif
   12              0.000050   let neocomplete.linenr = line('.')
                            
   12              0.000050   if &l:foldmethod ==# 'expr' && foldlevel('.') != 0
                                foldopen
                              endif

FUNCTION  neocomplete#handler#_on_insert_char_pre()
Called 144 times
Total time:   0.041558
 Self time:   0.004139

count  total (s)   self (s)
  144   0.009853   0.001112   if neocomplete#is_cache_disabled()
                                return
                              endif
                            
  144   0.001703   0.000670   let neocomplete = neocomplete#get_current_neocomplete()
  144              0.000661   if neocomplete.old_char != ' ' && v:char == ' ' && v:count == 0
    8   0.027693   0.000048     call s:make_cache_current_line()
    8              0.000005   endif
                            
  144              0.000398   let neocomplete.old_char = v:char

FUNCTION  neocomplete#is_locked()
Called 279 times
Total time:   0.010888
 Self time:   0.001617

count  total (s)   self (s)
  279   0.010727   0.001456   return neocomplete#is_cache_disabled() || &paste || g:neocomplete#disable_auto_complete

FUNCTION  <SNR>41_get_char()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000003   let idx = col('.') - 1
    1              0.000002   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
    1              0.000004     let line = getline('.')[idx :]
    1              0.000002     let pos = a:0 ? a:1 : 0
    1              0.000012     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
                              let line = getline('.')[: idx - 1]
                              let pos = 0 - (1 + a:1)
                              return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  airline#highlighter#get_highlight()
Called 1256 times
Total time:   0.134412
 Self time:   0.041304

count  total (s)   self (s)
 1256   0.045378   0.006057   let fg = s:get_syn(a:group, 'fg')
 1256   0.042734   0.005993   let bg = s:get_syn(a:group, 'bg')
 1256              0.020168   let reverse = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1256   0.024999   0.007953   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 271 times
Total time:   0.022511
 Self time:   0.003281

count  total (s)   self (s)
  271   0.020871   0.001641   let errors = SyntasticStatuslineFlag()
  271              0.000616   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
  271              0.000183   return ''

FUNCTION  gitgutter#diff#parse_diff()
Called 3 times
Total time:   0.001809
 Self time:   0.000552

count  total (s)   self (s)
    3              0.000020   let hunks = []
   24              0.000175   for line in split(a:diff, '\n')
   21   0.001443   0.000186     let hunk_info = gitgutter#diff#parse_hunk(line)
   21              0.000039     if len(hunk_info) == 4
   21              0.000044       call add(hunks, hunk_info)
   21              0.000013     endif
   21              0.000030   endfor
    3              0.000003   return hunks

FUNCTION  270()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000008     return copy(self._rawLoclist)

FUNCTION  272()
Called 6 times
Total time:   0.000294
 Self time:   0.000085

count  total (s)   self (s)
    6   0.000284   0.000075     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  274()
Called 271 times
Total time:   0.014504
 Self time:   0.014504

count  total (s)   self (s)
  271              0.000859     if !exists('self._stl_format')
    3              0.000007         let self._stl_format = ''
    3              0.000002     endif
  271              0.000637     if !exists('self._stl_flag')
    3              0.000007         let self._stl_flag = ''
    3              0.000003     endif
                            
  271              0.000570     if g:syntastic_stl_format !=# self._stl_format
    3              0.000005         let self._stl_format = g:syntastic_stl_format
                            
    3              0.000007         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        "sub in the total errors/warnings/both
                                        let output = substitute(output, '\m\C%w', num_warnings, 'g')
                                        let output = substitute(output, '\m\C%e', num_errors, 'g')
                                        let output = substitute(output, '\m\C%t', num_issues, 'g')
                            
                                        "first error/warning line num
                                        let output = substitute(output, '\m\C%F', num_issues ? self._rawLoclist[0]['lnum'] : '', 'g')
                            
                                        "first error line num
                                        let output = substitute(output, '\m\C%fe', num_errors ? errors[0]['lnum'] : '', 'g')
                            
                                        "first warning line num
                                        let output = substitute(output, '\m\C%fw', num_warnings ? warnings[0]['lnum'] : '', 'g')
                            
                                        let self._stl_flag = output
                                    else
    3              0.000007             let self._stl_flag = ''
    3              0.000003         endif
    3              0.000001     endif
                            
  271              0.000337     return self._stl_flag

FUNCTION  279()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000016     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  <SNR>98_invoke_funcrefs()
Called 2 times
Total time:   0.011071
 Self time:   0.000173

count  total (s)   self (s)
    2   0.000088   0.000016   let builder = airline#builder#new(a:context)
    2   0.002186   0.000030   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    2              0.000004   if err == 1
    2   0.008694   0.000024     let a:context.line = builder.build()
    2              0.000061     let s:contexts[a:context.winnr] = a:context
    2              0.000028     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    2              0.000001   endif

FUNCTION  <SNR>41_is_jump()
Called 1 time
Total time:   0.000082
 Self time:   0.000024

count  total (s)   self (s)
                              " Returns 1 if the next character is a closing delimiter.
    1   0.000032   0.000008   let char = s:get_char(0)
    1   0.000043   0.000009   let list = s:get('right_delims') + s:get('quotes_list')
                            
                              " Closing delimiter on the right.
    1              0.000004   if (!a:0 && index(list, char) > -1) || (a:0 && char == a:1)
    1              0.000000     return 1
                              endif
                            
                              " Closing delimiter with space expansion.
                              let nchar = s:get_char(1)
                              if !a:0 && s:get('expand_space') && char == " "
                                if index(list, nchar) > -1
                                  return 2
                                endif
                              elseif a:0 && s:get('expand_space') && nchar == a:1 && char == ' '
                                return 3
                              endif
                            
                              if !s:get('jump_expansion')
                                return 0
                              endif
                            
                              " Closing delimiter with CR expansion.
                              let uchar = matchstr(getline(line('.') + 1), '^\s*\zs\S')
                              if !a:0 && s:get('expand_cr') && char == ""
                                if index(list, uchar) > -1
                                  return 4
                                endif
                              elseif a:0 && s:get('expand_cr') && uchar == a:1
                                return 5
                              endif
                              return 0

FUNCTION  syntastic#util#compareLexi()
Called 6 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    6              0.000072     for idx in range(max([len(a:a), len(a:b)]))
    6              0.000029         let a_element = str2nr(get(a:a, idx, 0))
    6              0.000025         let b_element = str2nr(get(a:b, idx, 0))
    6              0.000010         if a_element != b_element
    6              0.000017             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " Everything matched, so it is at least the required version.
                                return 0

FUNCTION  gitgutter#sign#update_signs()
Called 3 times
Total time:   0.022313
 Self time:   0.000239

count  total (s)   self (s)
    3   0.008405   0.000024   call gitgutter#sign#find_current_signs()
                            
    3              0.000090   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    3   0.001410   0.000028   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
    3              0.000012   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    3              0.000003   if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
    3   0.000102   0.000021   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
    3   0.012253   0.000023   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
    3              0.000005   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif

FUNCTION  neocomplete#smart_close_popup()
Called 15 times
Total time:   0.001016
 Self time:   0.000197

count  total (s)   self (s)
   15   0.000978   0.000159   return neocomplete#mappings#smart_close_popup()

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 27 times
Total time:   0.002292
 Self time:   0.000948

count  total (s)   self (s)
   27              0.000096   if getbufvar(a:bufnr, '&modified')
   24              0.000256     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   24              0.000020   else
    3              0.000036     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    3              0.000002   endif
                            
   27              0.000051   if !empty(colors)
   27   0.001592   0.000248     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   27              0.000019   endif

FUNCTION  neocomplete#util#convert2list()
Called 524 times
Total time:   0.002253
 Self time:   0.002253

count  total (s)   self (s)
  524              0.001965   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  <SNR>139_debug()
Called 108 times
Total time:   0.000785
 Self time:   0.000785

count  total (s)   self (s)
  108              0.000160     if s:debug
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 6 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    6              0.000018   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
    6              0.000011   return s:using_xolox_shell

FUNCTION  280()
Called 3 times
Total time:   0.000308
 Self time:   0.000099

count  total (s)   self (s)
    3   0.000033   0.000013     call self.setOwner(bufnr(''))
    3   0.000035   0.000014     let self._stamp = syntastic#util#stamp()
    6   0.000186   0.000018     for buf in self.getBuffers()
    3              0.000030         call setbufvar(buf, 'syntastic_loclist', self)
    3              0.000002     endfor

FUNCTION  281()
Called 3 times
Total time:   0.000175
 Self time:   0.000049

count  total (s)   self (s)
    6   0.000147   0.000021     for buf in self.getBuffers()
    3              0.000011         call setbufvar(buf, 'syntastic_loclist', {})
    3              0.000003     endfor

FUNCTION  neocomplete#helper#clear_result()
Called 19 times
Total time:   0.005631
 Self time:   0.002724

count  total (s)   self (s)
   19   0.000443   0.000157   let neocomplete = neocomplete#get_current_neocomplete()
                            
   19              0.000078   let neocomplete.complete_str = ''
   19              0.000103   let neocomplete.candidates = []
   19              0.000052   let neocomplete.complete_sources = []
   19              0.000038   let neocomplete.complete_pos = -1
                            
                              " Restore completeopt.
   19              0.000101   if neocomplete.completeopt !=# &completeopt
                                " Restore completeopt.
                                let &completeopt = neocomplete.completeopt
                              endif
                            
                              " Clear context.
  228   0.000740   0.000512   for source in values(neocomplete#variables#get_sources())
  209   0.003514   0.001121     let source.neocomplete__context = neocomplete#init#_context( source.neocomplete__context)
  209              0.000231   endfor

FUNCTION  gitgutter#sign#find_current_signs()
Called 3 times
Total time:   0.008381
 Self time:   0.008372

count  total (s)   self (s)
    3   0.000024   0.000015   let bufnr = gitgutter#utility#bufnr()
    3              0.000016   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    3              0.000005   let other_signs = []      " [<line_number (number),...]
    3              0.000005   let dummy_sign_placed = 0
                            
    3              0.000010   redir => signs
    3              0.000152     silent execute "sign place buffer=" . bufnr
    3              0.000010   redir END
                            
  133              0.000617   for sign_line in filter(split(signs, '\n'), 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
  130              0.001441     let components  = split(sign_line)
  130              0.000782     let name        = split(components[2], '=')[1]
  130              0.000476     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
  130              0.000772       let line_number = str2nr(split(components[0], '=')[1])
  130              0.000394       if name =~# 'GitGutter'
  130              0.000745         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
  130              0.000330         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
  130              0.000607         let gitgutter_signs[line_number] = {'id': id, 'name': name}
  130              0.000080       else
                                    call add(other_signs, line_number)
                                  endif
  130              0.000099     end
  130              0.000120   endfor
                            
    3              0.000017   call setbufvar(bufnr, 'gitgutter_dummy_sign', dummy_sign_placed)
    3              0.000479   call setbufvar(bufnr, 'gitgutter_gitgutter_signs', gitgutter_signs)
    3              0.000014   call setbufvar(bufnr, 'gitgutter_other_signs', other_signs)

FUNCTION  syntastic#util#shexpand()
Called 3 times
Total time:   0.000069
 Self time:   0.000024

count  total (s)   self (s)
    3   0.000066   0.000021     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  airline#extensions#hunks#get_hunks()
Called 270 times
Total time:   0.025954
 Self time:   0.014915

count  total (s)   self (s)
  270              0.000810   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
  270   0.012318   0.001279   let hunks = s:get_hunks()
  270              0.000357   let string = ''
  270              0.000484   if !empty(hunks)
 1080              0.001465     for i in [0, 1, 2]
  810              0.001348       if s:non_zero_only == 0 || hunks[i] > 0
  810              0.004999         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  810              0.000567       endif
  810              0.000462     endfor
  270              0.000145   endif
  270              0.000256   return string

FUNCTION  syntastic#util#dictFilter()
Called 3 times
Total time:   0.000421
 Self time:   0.000073

count  total (s)   self (s)
    3   0.000374   0.000026     let rules = s:_translateFilter(a:filter)
                                " call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, "applying filter:", rules)
    3              0.000003     try
    3              0.000020         call filter(a:errors, rules)
    3              0.000003     catch /\m^Vim\%((\a\+)\)\=:E/
                                    let msg = matchstr(v:exception, '\m^Vim\%((\a\+)\)\=:\zs.*')
                                    call syntastic#log#error('quiet_messages: ' . msg)
                                endtry

FUNCTION  292()
Called 3 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    3              0.000011     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    3              0.000004         let self._mode = 'active'
    3              0.000009         let self._activeFiletypes = []
    3              0.000009         let self._passiveFiletypes = []
    3              0.000003     endif

FUNCTION  294()
Called 3 times
Total time:   0.000196
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000018     let local_mode = get(b:, 'syntastic_mode', '')
    3              0.000008     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    3   0.000159   0.000017     return self.allowsAutoChecking(&filetype)

FUNCTION  syntastic#util#argsescape()
Called 45 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   45              0.000140     if type(a:opt) == type('') && a:opt !=# ''
    9              0.000016         return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
   36              0.000029     return []

FUNCTION  SyntasticStatuslineFlag()
Called 271 times
Total time:   0.019230
 Self time:   0.002148

count  total (s)   self (s)
  271   0.019041   0.001959     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#util#prepend()
Called 297 times
Total time:   0.002501
 Self time:   0.002501

count  total (s)   self (s)
  297              0.000590   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  297              0.001274   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>125_is_branch_empty()
Called 270 times
Total time:   0.001531
 Self time:   0.001531

count  total (s)   self (s)
  270              0.001410   return exists('*airline#extensions#branch#head') && empty(airline#extensions#branch#head())

FUNCTION  unite#sources#history_yank#_append()
Called 66 times
Total time:   0.014554
 Self time:   0.004661

count  total (s)   self (s)
   66   0.002949   0.000337   call s:load()
                            
   66              0.002087   let prev_histories = copy(s:yank_histories)
                            
   66   0.001825   0.000389   call s:add_register('"')
                            
   66              0.000106   if g:unite_source_history_yank_save_clipboard
                                " Skip if registers are identical.
                                if @" !=# @+
                                  call s:add_register('+')
                                endif
                              endif
                            
   66              0.000193   if prev_histories !=# s:yank_histories
                                " Updated.
                            
    9              0.000025     if g:unite_source_history_yank_limit < len(s:yank_histories)
    9              0.000288       let s:yank_histories = s:yank_histories[ : g:unite_source_history_yank_limit - 1]
    9              0.000006     endif
                            
    9   0.005905   0.000060     call s:save()
    9              0.000010   endif

FUNCTION  <SNR>135_get_section()
Called 13 times
Total time:   0.000631
 Self time:   0.000564

count  total (s)   self (s)
   13              0.000065   if has_key(s:section_truncate_width, a:key)
    7              0.000043     if winwidth(a:winnr) < s:section_truncate_width[a:key]
    4              0.000006       return ''
                                endif
    3              0.000003   endif
    9              0.000025   let spc = g:airline_symbols.space
    9   0.000245   0.000178   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
    9              0.000110   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
    9              0.000046   return empty(text) ? '' : prefix.text.suffix

FUNCTION  gitgutter#hunk#set_hunks()
Called 3 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
    3              0.000150   let s:hunks = a:hunks

FUNCTION  airline#builder#new()
Called 2 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000018   let builder = copy(s:prototype)
    2              0.000006   let builder._context = a:context
    2              0.000005   let builder._sections = []
                            
    2              0.000032   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    2              0.000003   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    3   0.493237   0.000135  <SNR>85_BufWritePostHook()
    3   0.493057   0.000506  <SNR>85_UpdateErrors()
    3   0.489506   0.001024  <SNR>85_CacheErrors()
    3   0.485473   0.000072  243()
    3   0.485193   0.000232  242()
    3   0.484181   0.000151  SyntaxCheckers_cs_mcs_GetLocList()
    3   0.482681   0.001621  SyntasticMake()
    3   0.480736   0.000992  syntastic#util#system()
  298   0.386564   0.021371  airline#check_mode()
   27   0.362901   0.098110  airline#highlighter#highlight()
  279   0.252530   0.023701  neocomplete#handler#_do_auto_complete()
  621   0.182148   0.020422  <SNR>130_exec_separator()
 1242   0.140934   0.008656  airline#themes#get_highlight()
 1256   0.134412   0.041304  airline#highlighter#get_highlight()
  262   0.131030   0.034882  neocomplete#complete#_set_results_pos()
  135   0.129255   0.016149  neocomplete#handler#_on_text_changed()
 3195   0.108353             airline#highlighter#exec()
    5   0.089641   0.002014  <SNR>139_AutoUpdate()
    3   0.085464   0.010611  <SNR>139_ProcessFile()
 2512   0.076062             <SNR>130_get_syn()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 3195              0.108353  airline#highlighter#exec()
   27   0.362901   0.098110  airline#highlighter#highlight()
 2512              0.076062  <SNR>130_get_syn()
  337              0.053743  <SNR>105_Highlight_Matching_Pair()
  282              0.041900  <SNR>192_uniq_by()
 1256   0.134412   0.041304  airline#highlighter#get_highlight()
  262   0.131030   0.034882  neocomplete#complete#_set_results_pos()
  188              0.029752  UltiSnips#CursorMoved()
  262   0.040955   0.028626  <SNR>191_get_omni_funcs()
  279   0.252530   0.023701  neocomplete#handler#_do_auto_complete()
  298   0.386564   0.021371  airline#check_mode()
   20   0.058924   0.020925  <SNR>179_make_cache_current_buffer()
  621   0.182148   0.020422  <SNR>130_exec_separator()
 2799              0.020307  neocomplete#get_current_neocomplete()
  279   0.021529   0.019719  neocomplete#helper#get_cur_text()
  279   0.024411   0.018498  <SNR>197_is_skip_auto_complete()
  302   0.022160   0.017267  neocomplete#helper#get_source_filetypes()
 1256              0.017046  <SNR>130_get_array()
  135   0.129255   0.016149  neocomplete#handler#_on_text_changed()
  558   0.023785   0.015518  neocomplete#is_cache_disabled()

